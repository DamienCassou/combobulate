;; START Production rules for yaml
(defconst combobulate-rules-yaml
  '(("alias" (:*unnamed* ("alias_name")))
    ("anchor" (:*unnamed* ("anchor_name")))
    ("block_mapping" (:*unnamed* ("block_mapping_pair")))
    ("block_mapping_pair" (:key ("block_node" "flow_node") :value ("block_node" "flow_node")))
    ("block_node" (:*unnamed* ("anchor" "block_mapping" "block_sequence" "block_scalar" "tag")))
    ("block_sequence" (:*unnamed* ("block_sequence_item")))
    ("block_sequence_item" (:*unnamed* ("block_node" "flow_node")))
    ("document" (:*unnamed* ("block_node" "flow_node" "tag_directive" "reserved_directive" "yaml_directive")))
    ("double_quote_scalar" (:*unnamed* ("escape_sequence")))
    ("flow_mapping" (:*unnamed* ("flow_pair" "flow_node")))
    ("flow_node" (:*unnamed* ("plain_scalar" "single_quote_scalar" "flow_sequence" "flow_mapping" "tag" "anchor" "double_quote_scalar" "alias")))
    ("flow_pair" (:key ("flow_node") :value ("flow_node")))
    ("flow_sequence" (:*unnamed* ("flow_pair" "flow_node")))
    ("plain_scalar" (:*unnamed* ("float_scalar" "null_scalar" "integer_scalar" "boolean_scalar" "string_scalar")))
    ("reserved_directive" (:*unnamed* ("directive_name" "directive_parameter")))
    ("single_quote_scalar" (:*unnamed* ("escape_sequence")))
    ("stream" (:*unnamed* ("document")))
    ("tag_directive" (:*unnamed* ("tag_prefix" "tag_handle")))
    ("yaml_directive" (:*unnamed* ("yaml_version")))
    ("alias_name" (:*unnamed* nil))
    ("anchor_name" (:*unnamed* nil))
    ("boolean_scalar" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("directive_name" (:*unnamed* nil))
    ("directive_parameter" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("float_scalar" (:*unnamed* nil))
    ("integer_scalar" (:*unnamed* nil))
    ("null_scalar" (:*unnamed* nil))
    ("string_scalar" (:*unnamed* nil))
    ("tag" (:*unnamed* nil))
    ("tag_handle" (:*unnamed* nil))
    ("tag_prefix" (:*unnamed* nil))
    ("yaml_version" (:*unnamed* nil))
    ))
;; END Production rules for yaml
;; START Inverse production rules for yaml
(defconst combobulate-rules-yaml-inverse
  '(("alias" ("flow_node"))
    ("alias_name" ("alias"))
    ("anchor" ("block_node" "flow_node"))
    ("anchor_name" ("anchor"))
    ("block_mapping" ("block_node"))
    ("block_mapping_pair" ("block_mapping"))
    ("block_node" ("block_sequence_item" "document" "block_mapping_pair"))
    ("block_scalar" ("block_node"))
    ("block_sequence" ("block_node"))
    ("block_sequence_item" ("block_sequence"))
    ("boolean_scalar" ("plain_scalar"))
    ("directive_name" ("reserved_directive"))
    ("directive_parameter" ("reserved_directive"))
    ("document" ("stream"))
    ("double_quote_scalar" ("flow_node"))
    ("escape_sequence" ("double_quote_scalar" "single_quote_scalar"))
    ("float_scalar" ("plain_scalar"))
    ("flow_mapping" ("flow_node"))
    ("flow_node" ("block_sequence_item" "document" "flow_sequence" "flow_mapping" "flow_pair" "block_mapping_pair"))
    ("flow_pair" ("flow_sequence" "flow_mapping"))
    ("flow_sequence" ("flow_node"))
    ("integer_scalar" ("plain_scalar"))
    ("null_scalar" ("plain_scalar"))
    ("plain_scalar" ("flow_node"))
    ("reserved_directive" ("document"))
    ("single_quote_scalar" ("flow_node"))
    ("string_scalar" ("plain_scalar"))
    ("tag" ("block_node" "flow_node"))
    ("tag_directive" ("document"))
    ("tag_handle" ("tag_directive"))
    ("tag_prefix" ("tag_directive"))
    ("yaml_directive" ("document"))
    ("yaml_version" ("yaml_directive"))
    )
  )
;; END Inverse production rules for yaml
;; START All node types in yaml
(defconst combobulate-rules-yaml-types
  '("alias" "alias_name" "anchor" "anchor_name" "block_mapping" "block_mapping_pair" "block_node" "block_scalar" "block_sequence" "block_sequence_item" "boolean_scalar" "comment" "directive_name" "directive_parameter" "document" "double_quote_scalar" "escape_sequence" "float_scalar" "flow_mapping" "flow_node" "flow_pair" "flow_sequence" "integer_scalar" "null_scalar" "plain_scalar" "reserved_directive" "single_quote_scalar" "stream" "string_scalar" "tag" "tag_directive" "tag_handle" "tag_prefix" "yaml_directive" "yaml_version")
  )
;; END All node types in yaml

;; START Production rules for tsx
(defconst combobulate-rules-tsx
  '(("_primary_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("declaration" (:*unnamed* ("ambient_declaration" "interface_declaration" "internal_module" "module" "variable_declaration" "lexical_declaration" "function_signature" "generator_function_declaration" "abstract_class_declaration" "function_declaration" "class_declaration" "import_alias" "enum_declaration" "type_alias_declaration")))
    ("expression" (:*unnamed* ("yield_expression" "as_expression" "binary_expression" "satisfies_expression" "augmented_assignment_expression" "new_expression" "internal_module" "assignment_expression" "primary_expression" "jsx_element" "jsx_self_closing_element" "instantiation_expression" "update_expression" "await_expression" "glimmer_template" "ternary_expression" "unary_expression")))
    ("pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "rest_pattern" "non_null_expression" "subscript_expression")))
    ("primary_expression" (:*unnamed* ("member_expression" "array" "identifier" "string" "undefined" "parenthesized_expression" "arrow_function" "generator_function" "template_string" "call_expression" "class" "function" "subscript_expression" "false" "number" "regex" "super" "import" "object" "true" "this" "null" "meta_property" "non_null_expression")))
    ("statement" (:*unnamed* ("continue_statement" "for_statement" "with_statement" "export_statement" "import_statement" "if_statement" "do_statement" "declaration" "return_statement" "throw_statement" "for_in_statement" "while_statement" "empty_statement" "switch_statement" "expression_statement" "break_statement" "debugger_statement" "try_statement" "statement_block" "labeled_statement")))
    ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("ambient_declaration" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "declaration" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "statement_block" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type" "property_identifier")))
    ("arguments" (:*unnamed* ("spread_element" "expression")))
    ("array" (:*unnamed* ("spread_element" "expression")))
    ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
    ("array_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("as_expression" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "expression" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("asserts" (:*unnamed* ("this" "identifier" "type_predicate")))
    ("asserts_annotation" (:*unnamed* ("asserts")))
    ("assignment_expression" (:left ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "parenthesized_expression" "non_null_expression" "subscript_expression") :right ("expression")))
    ("assignment_pattern" (:left ("pattern") :right ("expression")))
    ("augmented_assignment_expression" (:left ("member_expression" "identifier" "parenthesized_expression" "non_null_expression" "subscript_expression") :operator nil :right ("expression")))
    ("await_expression" (:*unnamed* ("expression")))
    ("binary_expression" (:left ("expression") :operator nil :right ("expression")))
    ("break_statement" (:label ("statement_identifier")))
    ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments")))
    ("call_signature" (:parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("catch_clause" (:body ("statement_block") :parameter ("object_pattern" "identifier" "array_pattern") :type ("type_annotation")))
    ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("class_body" (:*unnamed* ("method_signature" "class_static_block" "abstract_method_signature" "public_field_definition" "method_definition" "decorator" "index_signature")))
    ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause")))
    ("class_static_block" (:body ("statement_block")))
    ("computed_property_name" (:*unnamed* ("expression")))
    ("conditional_type" (:alternative ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :consequence ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :left ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :right ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("constraint" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("construct_signature" (:parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters")))
    ("constructor_type" (:parameters ("formal_parameters") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :type_parameters ("type_parameters")))
    ("continue_statement" (:label ("statement_identifier")))
    ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression")))
    ("default_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("do_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("else_clause" (:*unnamed* ("statement")))
    ("enum_assignment" (:name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("enum_body" (:*unnamed* ("enum_assignment") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier")))
    ("enum_declaration" (:body ("enum_body") :name ("identifier")))
    ("export_clause" (:*unnamed* ("export_specifier")))
    ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier")))
    ("export_statement" (:*unnamed* ("namespace_export" "export_clause" "identifier" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
    ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("extends_clause" (:type_arguments ("type_arguments") :value ("expression")))
    ("extends_type_clause" (:type ("type_identifier" "generic_type" "nested_type_identifier")))
    ("finally_clause" (:body ("statement_block")))
    ("flow_maybe_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "parenthesized_expression" "non_null_expression" "subscript_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
    ("for_statement" (:body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("lexical_declaration" "expression_statement" "variable_declaration" "empty_statement")))
    ("formal_parameters" (:*unnamed* ("required_parameter" "optional_parameter")))
    ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_signature" (:name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_type" (:parameters ("formal_parameters") :return_type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "type_predicate" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "asserts" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :type_parameters ("type_parameters")))
    ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("generic_type" (:name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments")))
    ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
    ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
    ("implements_clause" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("import_alias" (:*unnamed* ("identifier" "nested_identifier")))
    ("import_clause" (:*unnamed* ("namespace_import" "identifier" "named_imports")))
    ("import_require_clause" (:*unnamed* ("identifier") :source ("string")))
    ("import_specifier" (:alias ("identifier") :name ("string" "identifier")))
    ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string")))
    ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :name ("identifier") :sign nil :type ("type_annotation" "opting_type_annotation" "omitting_type_annotation")))
    ("index_type_query" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("infer_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("instantiation_expression" (:*unnamed* ("expression") :function ("member_expression" "import" "identifier" "subscript_expression") :type_arguments ("type_arguments")))
    ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("internal_module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier")))
    ("intersection_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_namespace_name" "jsx_element" "string" "jsx_self_closing_element" "property_identifier")))
    ("jsx_closing_element" (:name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_text" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
    ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
    ("jsx_namespace_name" (:*unnamed* ("identifier")))
    ("jsx_opening_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier") :type_arguments ("type_arguments")))
    ("jsx_self_closing_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier") :type_arguments ("type_arguments")))
    ("labeled_statement" (:body ("statement") :label ("statement_identifier")))
    ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
    ("literal_type" (:*unnamed* ("false" "string" "undefined" "null" "number" "true" "unary_expression")))
    ("lookup_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("mapped_type_clause" (:alias ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :name ("type_identifier") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier")))
    ("method_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :body ("statement_block") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("method_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier")))
    ("named_imports" (:*unnamed* ("import_specifier")))
    ("namespace_export" (:*unnamed* ("string" "identifier")))
    ("namespace_import" (:*unnamed* ("identifier")))
    ("nested_identifier" (:*unnamed* ("member_expression" "identifier" "property_identifier")))
    ("nested_type_identifier" (:module ("identifier" "nested_identifier") :name ("type_identifier")))
    ("new_expression" (:arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments")))
    ("non_null_expression" (:*unnamed* ("expression")))
    ("object" (:*unnamed* ("method_definition" "pair" "spread_element" "shorthand_property_identifier")))
    ("object_assignment_pattern" (:left ("shorthand_property_identifier_pattern" "object_pattern" "array_pattern") :right ("expression")))
    ("object_pattern" (:*unnamed* ("shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern" "pair_pattern")))
    ("object_type" (:*unnamed* ("call_signature" "property_signature" "construct_signature" "export_statement" "method_signature" "index_signature")))
    ("omitting_type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("opting_type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("optional_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression")))
    ("optional_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("pair" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("pair_pattern" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("pattern" "assignment_pattern")))
    ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation")))
    ("parenthesized_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("program" (:*unnamed* ("hash_bang_line" "statement")))
    ("property_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :type ("type_annotation")))
    ("public_field_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :type ("type_annotation") :value ("expression")))
    ("readonly_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("regex" (:flags ("regex_flags") :pattern ("regex_pattern")))
    ("required_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier" "rest_pattern") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression")))
    ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "non_null_expression" "subscript_expression")))
    ("rest_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("satisfies_expression" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "expression" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression")))
    ("spread_element" (:*unnamed* ("expression")))
    ("statement_block" (:*unnamed* ("statement")))
    ("string" (:*unnamed* ("string_fragment" "escape_sequence")))
    ("subscript_expression" (:index ("sequence_expression" "predefined_type" "string" "expression" "number") :object ("expression") :optional_chain ("optional_chain")))
    ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
    ("switch_case" (:body ("statement") :value ("sequence_expression" "expression")))
    ("switch_default" (:body ("statement")))
    ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression")))
    ("template_literal_type" (:*unnamed* ("template_type")))
    ("template_string" (:*unnamed* ("template_substitution" "escape_sequence")))
    ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
    ("template_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression")))
    ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
    ("tuple_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "optional_type" "tuple_type" "flow_maybe_type" "intersection_type" "rest_type" "generic_type" "lookup_type" "infer_type" "optional_parameter" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "required_parameter" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_alias_declaration" (:name ("type_identifier") :type_parameters ("type_parameters") :value ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_arguments" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_parameter" (:constraint ("constraint") :name ("type_identifier") :value ("default_type")))
    ("type_parameters" (:*unnamed* ("type_parameter")))
    ("type_predicate" (:name ("this" "identifier") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_predicate_annotation" (:*unnamed* ("type_predicate")))
    ("type_query" (:*unnamed* ("member_expression" "identifier" "call_expression" "instantiation_expression" "subscript_expression")))
    ("unary_expression" (:argument ("number" "expression") :operator nil))
    ("union_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("update_expression" (:argument ("expression") :operator nil))
    ("variable_declaration" (:*unnamed* ("variable_declarator")))
    ("variable_declarator" (:name ("object_pattern" "identifier" "array_pattern") :type ("type_annotation") :value ("expression")))
    ("while_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("with_statement" (:body ("statement") :object ("parenthesized_expression")))
    ("yield_expression" (:*unnamed* ("expression")))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("hash_bang_line" (:*unnamed* nil))
    ("null" (:*unnamed* nil))
    ("number" (:*unnamed* nil))
    ("private_property_identifier" (:*unnamed* nil))
    ("property_identifier" (:*unnamed* nil))
    ("regex_flags" (:*unnamed* nil))
    ("regex_pattern" (:*unnamed* nil))
    ("shorthand_property_identifier" (:*unnamed* nil))
    ("shorthand_property_identifier_pattern" (:*unnamed* nil))
    ("statement_identifier" (:*unnamed* nil))
    ("string_fragment" (:*unnamed* nil))
    ("super" (:*unnamed* nil))
    ("this" (:*unnamed* nil))
    ("this_type" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("type_identifier" (:*unnamed* nil))
    ("undefined" (:*unnamed* nil))
    ))
;; END Production rules for tsx
;; START Inverse production rules for tsx
(defconst combobulate-rules-tsx-inverse
  '(("abstract_class_declaration" ("declaration"))
    ("abstract_method_signature" ("class_body"))
    ("accessibility_modifier" ("abstract_method_signature" "public_field_definition" "method_definition" "required_parameter" "method_signature" "property_signature" "optional_parameter"))
    ("ambient_declaration" ("declaration"))
    ("arguments" ("new_expression" "call_expression"))
    ("array" ("primary_expression"))
    ("array_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("array_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("arrow_function" ("primary_expression"))
    ("as_expression" ("expression"))
    ("asserts" ("asserts_annotation" "function_type"))
    ("asserts_annotation" ("abstract_method_signature" "method_definition" "arrow_function" "function_signature" "generator_function" "generator_function_declaration" "function_declaration" "method_signature" "call_signature" "function"))
    ("assignment_expression" ("expression"))
    ("assignment_pattern" ("pair_pattern" "array_pattern"))
    ("augmented_assignment_expression" ("expression"))
    ("await_expression" ("expression"))
    ("binary_expression" ("expression"))
    ("break_statement" ("statement"))
    ("call_expression" ("primary_expression" "decorator" "type_query"))
    ("call_signature" ("object_type"))
    ("catch_clause" ("try_statement"))
    ("class" ("primary_expression"))
    ("class_body" ("abstract_class_declaration" "class_declaration" "class"))
    ("class_declaration" ("declaration"))
    ("class_heritage" ("abstract_class_declaration" "class_declaration" "class"))
    ("class_static_block" ("class_body"))
    ("computed_property_name" ("abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("conditional_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("constraint" ("type_parameter"))
    ("construct_signature" ("object_type"))
    ("constructor_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("continue_statement" ("statement"))
    ("debugger_statement" ("statement"))
    ("declaration" ("ambient_declaration" "export_statement" "statement"))
    ("decorator" ("optional_parameter" "required_parameter" "export_statement" "abstract_class_declaration" "class_declaration" "class_body" "class"))
    ("default_type" ("type_parameter"))
    ("do_statement" ("statement"))
    ("else_clause" ("if_statement"))
    ("empty_statement" ("for_statement" "statement"))
    ("enum_assignment" ("enum_body"))
    ("enum_body" ("enum_declaration"))
    ("enum_declaration" ("declaration"))
    ("escape_sequence" ("template_string" "string"))
    ("existential_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("export_clause" ("export_statement"))
    ("export_specifier" ("export_clause"))
    ("export_statement" ("object_type" "statement"))
    ("expression" ("jsx_expression" "member_expression" "sequence_expression" "parenthesized_expression" "spread_element" "binary_expression" "return_statement" "computed_property_name" "switch_case" "required_parameter" "instantiation_expression" "await_expression" "ternary_expression" "pair" "enum_assignment" "object_assignment_pattern" "non_null_expression" "variable_declarator" "template_substitution" "array" "public_field_definition" "for_statement" "yield_expression" "export_statement" "arrow_function" "as_expression" "satisfies_expression" "call_expression" "augmented_assignment_expression" "extends_clause" "for_in_statement" "throw_statement" "optional_parameter" "subscript_expression" "assignment_expression" "arguments" "expression_statement" "update_expression" "assignment_pattern" "unary_expression"))
    ("expression_statement" ("for_statement" "statement"))
    ("extends_clause" ("class_heritage"))
    ("extends_type_clause" ("interface_declaration"))
    ("false" ("primary_expression" "literal_type"))
    ("finally_clause" ("try_statement"))
    ("flow_maybe_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("for_in_statement" ("statement"))
    ("for_statement" ("statement"))
    ("formal_parameters" ("abstract_method_signature" "function_type" "method_definition" "construct_signature" "arrow_function" "function_signature" "generator_function" "constructor_type" "function_declaration" "generator_function_declaration" "method_signature" "call_signature" "function"))
    ("function" ("primary_expression"))
    ("function_declaration" ("declaration"))
    ("function_signature" ("declaration"))
    ("function_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("generator_function" ("primary_expression"))
    ("generator_function_declaration" ("declaration"))
    ("generic_type" ("function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("glimmer_closing_tag" ("glimmer_template"))
    ("glimmer_opening_tag" ("glimmer_template"))
    ("glimmer_template" ("expression"))
    ("hash_bang_line" ("program"))
    ("identifier" ("member_expression" "type_query" "jsx_closing_element" "rest_pattern" "enum_declaration" "internal_module" "type_predicate" "namespace_import" "export_specifier" "module" "jsx_self_closing_element" "instantiation_expression" "required_parameter" "function_signature" "generator_function_declaration" "function_declaration" "variable_declarator" "import_clause" "catch_clause" "import_require_clause" "export_statement" "arrow_function" "generator_function" "namespace_export" "augmented_assignment_expression" "import_alias" "import_specifier" "for_in_statement" "function" "optional_parameter" "assignment_expression" "primary_expression" "jsx_namespace_name" "pattern" "decorator" "nested_identifier" "index_signature" "asserts" "nested_type_identifier" "jsx_opening_element"))
    ("if_statement" ("statement"))
    ("implements_clause" ("class_heritage"))
    ("import" ("primary_expression" "instantiation_expression"))
    ("import_alias" ("declaration"))
    ("import_clause" ("import_statement"))
    ("import_require_clause" ("import_statement"))
    ("import_specifier" ("named_imports"))
    ("import_statement" ("statement"))
    ("index_signature" ("object_type" "class_body"))
    ("index_type_query" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("infer_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("instantiation_expression" ("expression" "type_query"))
    ("interface_declaration" ("declaration"))
    ("internal_module" ("declaration" "expression"))
    ("intersection_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("jsx_attribute" ("jsx_self_closing_element" "jsx_opening_element"))
    ("jsx_closing_element" ("jsx_element"))
    ("jsx_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_expression" ("jsx_self_closing_element" "jsx_attribute" "jsx_element" "jsx_opening_element"))
    ("jsx_namespace_name" ("jsx_self_closing_element" "jsx_attribute" "jsx_closing_element" "jsx_opening_element"))
    ("jsx_opening_element" ("jsx_element"))
    ("jsx_self_closing_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_text" ("jsx_element"))
    ("labeled_statement" ("statement"))
    ("lexical_declaration" ("for_statement" "declaration"))
    ("literal_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("lookup_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("mapped_type_clause" ("index_signature"))
    ("member_expression" ("member_expression" "primary_expression" "pattern" "type_query" "jsx_self_closing_element" "instantiation_expression" "jsx_closing_element" "decorator" "nested_identifier" "rest_pattern" "augmented_assignment_expression" "jsx_opening_element" "for_in_statement" "assignment_expression"))
    ("meta_property" ("primary_expression"))
    ("method_definition" ("object" "class_body"))
    ("method_signature" ("object_type" "class_body"))
    ("module" ("declaration"))
    ("named_imports" ("import_clause"))
    ("namespace_export" ("export_statement"))
    ("namespace_import" ("import_clause"))
    ("nested_identifier" ("module" "internal_module" "nested_type_identifier" "import_alias"))
    ("nested_type_identifier" ("function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "generic_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("new_expression" ("expression"))
    ("non_null_expression" ("primary_expression" "pattern" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("null" ("primary_expression" "literal_type"))
    ("number" ("primary_expression" "literal_type" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature" "subscript_expression" "unary_expression"))
    ("object" ("primary_expression"))
    ("object_assignment_pattern" ("object_pattern"))
    ("object_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("object_type" ("interface_declaration" "function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("omitting_type_annotation" ("index_signature"))
    ("opting_type_annotation" ("index_signature"))
    ("optional_chain" ("member_expression" "subscript_expression"))
    ("optional_parameter" ("formal_parameters" "tuple_type"))
    ("optional_type" ("tuple_type"))
    ("override_modifier" ("public_field_definition" "method_definition" "required_parameter" "method_signature" "property_signature" "optional_parameter"))
    ("pair" ("object"))
    ("pair_pattern" ("object_pattern"))
    ("parenthesized_expression" ("primary_expression" "while_statement" "switch_statement" "with_statement" "if_statement" "do_statement" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("parenthesized_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("pattern" ("array_pattern" "required_parameter" "assignment_pattern" "pair_pattern" "optional_parameter"))
    ("predefined_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "subscript_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("primary_expression" ("new_expression" "expression"))
    ("private_property_identifier" ("member_expression" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("property_identifier" ("ambient_declaration" "jsx_attribute" "member_expression" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "nested_identifier" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("property_signature" ("object_type"))
    ("public_field_definition" ("class_body"))
    ("readonly_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("regex" ("primary_expression"))
    ("regex_flags" ("regex"))
    ("regex_pattern" ("regex"))
    ("required_parameter" ("formal_parameters" "tuple_type"))
    ("rest_pattern" ("required_parameter" "pattern" "object_pattern"))
    ("rest_type" ("tuple_type"))
    ("return_statement" ("statement"))
    ("satisfies_expression" ("expression"))
    ("sequence_expression" ("jsx_expression" "sequence_expression" "parenthesized_expression" "for_statement" "throw_statement" "expression_statement" "return_statement" "switch_case" "for_in_statement" "template_substitution" "subscript_expression"))
    ("shorthand_property_identifier" ("object"))
    ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
    ("spread_element" ("array" "arguments" "jsx_expression" "object"))
    ("statement" ("switch_default" "while_statement" "for_statement" "statement_block" "with_statement" "if_statement" "do_statement" "else_clause" "labeled_statement" "program" "switch_case" "for_in_statement"))
    ("statement_block" ("ambient_declaration" "finally_clause" "method_definition" "module" "statement" "arrow_function" "generator_function" "generator_function_declaration" "try_statement" "function_declaration" "class_static_block" "internal_module" "function" "catch_clause"))
    ("statement_identifier" ("labeled_statement" "continue_statement" "break_statement"))
    ("string" ("enum_body" "method_signature" "internal_module" "export_specifier" "module" "method_definition" "pair" "enum_assignment" "property_signature" "jsx_attribute" "import_require_clause" "public_field_definition" "export_statement" "import_statement" "namespace_export" "import_specifier" "subscript_expression" "primary_expression" "literal_type" "abstract_method_signature" "pair_pattern"))
    ("string_fragment" ("string"))
    ("subscript_expression" ("primary_expression" "pattern" "type_query" "instantiation_expression" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("super" ("primary_expression"))
    ("switch_body" ("switch_statement"))
    ("switch_case" ("switch_body"))
    ("switch_default" ("switch_body"))
    ("switch_statement" ("statement"))
    ("template_literal_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("template_string" ("primary_expression" "call_expression"))
    ("template_substitution" ("template_string"))
    ("template_type" ("template_literal_type"))
    ("ternary_expression" ("expression"))
    ("this" ("primary_expression" "required_parameter" "type_predicate" "asserts" "optional_parameter"))
    ("this_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("throw_statement" ("statement"))
    ("true" ("primary_expression" "literal_type"))
    ("try_statement" ("statement"))
    ("tuple_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("type_alias_declaration" ("declaration"))
    ("type_annotation" ("parenthesized_expression" "method_signature" "call_signature" "method_definition" "required_parameter" "function_signature" "generator_function_declaration" "function_declaration" "property_signature" "variable_declarator" "catch_clause" "public_field_definition" "arrow_function" "generator_function" "optional_parameter" "function" "abstract_method_signature" "construct_signature" "index_signature"))
    ("type_arguments" ("jsx_self_closing_element" "instantiation_expression" "generic_type" "call_expression" "jsx_opening_element" "extends_clause" "new_expression"))
    ("type_identifier" ("interface_declaration" "function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "generic_type" "class_declaration" "tuple_type" "lookup_type" "default_type" "infer_type" "class" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "abstract_class_declaration" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "nested_type_identifier" "readonly_type" "type_parameter"))
    ("type_parameter" ("type_parameters"))
    ("type_parameters" ("interface_declaration" "method_signature" "abstract_method_signature" "function_type" "method_definition" "construct_signature" "arrow_function" "function_signature" "generator_function" "abstract_class_declaration" "constructor_type" "function_declaration" "class_declaration" "function" "generator_function_declaration" "call_signature" "class" "type_alias_declaration"))
    ("type_predicate" ("type_predicate_annotation" "asserts" "function_type"))
    ("type_predicate_annotation" ("abstract_method_signature" "method_definition" "arrow_function" "function_signature" "generator_function" "generator_function_declaration" "function_declaration" "method_signature" "call_signature" "function"))
    ("type_query" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("unary_expression" ("literal_type" "expression"))
    ("undefined" ("primary_expression" "literal_type" "pattern" "rest_pattern" "for_in_statement" "assignment_expression"))
    ("union_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("update_expression" ("expression"))
    ("variable_declaration" ("for_statement" "declaration"))
    ("variable_declarator" ("variable_declaration" "lexical_declaration"))
    ("while_statement" ("statement"))
    ("with_statement" ("statement"))
    ("yield_expression" ("expression"))
    )
  )
;; END Inverse production rules for tsx
;; START All node types in tsx
(defconst combobulate-rules-tsx-types
  '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
  )
;; END All node types in tsx

;; START Production rules for css
(defconst combobulate-rules-css
  '(("adjacent_sibling_selector" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("arguments" (:*unnamed* ("plain_value" "nesting_selector" "id_selector" "attribute_selector" "important" "namespace_selector" "binary_expression" "call_expression" "descendant_selector" "sibling_selector" "string_value" "color_value" "class_selector" "pseudo_class_selector" "child_selector" "pseudo_element_selector" "grid_value" "universal_selector" "float_value" "integer_value" "adjacent_sibling_selector" "parenthesized_value" "tag_name")))
    ("at_rule" (:*unnamed* ("feature_query" "keyword_query" "parenthesized_query" "selector_query" "at_keyword" "binary_query" "unary_query" "block")))
    ("attribute_name" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("attribute_selector" (:*unnamed* ("plain_value" "nesting_selector" "id_selector" "attribute_selector" "important" "namespace_selector" "binary_expression" "call_expression" "descendant_selector" "sibling_selector" "string_value" "color_value" "class_selector" "pseudo_class_selector" "child_selector" "pseudo_element_selector" "grid_value" "universal_selector" "attribute_name" "float_value" "integer_value" "adjacent_sibling_selector" "parenthesized_value" "tag_name")))
    ("binary_expression" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "integer_value" "binary_expression" "call_expression" "parenthesized_value" "color_value")))
    ("binary_query" (:*unnamed* ("selector_query" "feature_query" "binary_query" "unary_query" "keyword_query" "parenthesized_query")))
    ("block" (:*unnamed* ("rule_set" "media_statement" "supports_statement" "charset_statement" "import_statement" "at_rule" "postcss_statement" "declaration" "namespace_statement" "keyframes_statement")))
    ("call_expression" (:*unnamed* ("arguments" "function_name")))
    ("charset_statement" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "integer_value" "binary_expression" "call_expression" "parenthesized_value" "color_value")))
    ("child_selector" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("class_selector" (:*unnamed* ("child_selector" "tag_name" "class_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("declaration" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "integer_value" "binary_expression" "call_expression" "property_name" "parenthesized_value" "color_value")))
    ("descendant_selector" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("feature_query" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "feature_name" "binary_expression" "call_expression" "integer_value" "parenthesized_value" "color_value")))
    ("float_value" (:*unnamed* ("unit")))
    ("grid_value" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "integer_value" "binary_expression" "call_expression" "parenthesized_value" "color_value")))
    ("id_selector" (:*unnamed* ("child_selector" "id_name" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("import_statement" (:*unnamed* ("feature_query" "plain_value" "important" "binary_expression" "call_expression" "string_value" "color_value" "keyword_query" "grid_value" "parenthesized_query" "selector_query" "float_value" "integer_value" "unary_query" "binary_query" "parenthesized_value")))
    ("integer_value" (:*unnamed* ("unit")))
    ("keyframe_block" (:*unnamed* ("integer_value" "to" "from" "block")))
    ("keyframe_block_list" (:*unnamed* ("keyframe_block")))
    ("keyframes_statement" (:*unnamed* ("at_keyword" "keyframe_block_list" "keyframes_name")))
    ("media_statement" (:*unnamed* ("selector_query" "feature_query" "binary_query" "unary_query" "keyword_query" "block" "parenthesized_query")))
    ("namespace_selector" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("namespace_statement" (:*unnamed* ("namespace_name" "string_value" "call_expression")))
    ("parenthesized_query" (:*unnamed* ("selector_query" "feature_query" "binary_query" "unary_query" "keyword_query" "parenthesized_query")))
    ("parenthesized_value" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "integer_value" "binary_expression" "call_expression" "parenthesized_value" "color_value")))
    ("postcss_statement" (:*unnamed* ("string_value" "plain_value" "grid_value" "important" "float_value" "at_keyword" "binary_expression" "call_expression" "integer_value" "parenthesized_value" "color_value")))
    ("pseudo_class_selector" (:*unnamed* ("nesting_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "sibling_selector" "string_value" "class_selector" "pseudo_class_selector" "child_selector" "arguments" "class_name" "pseudo_element_selector" "universal_selector" "adjacent_sibling_selector" "tag_name")))
    ("pseudo_element_selector" (:*unnamed* ("child_selector" "arguments" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("rule_set" (:*unnamed* ("selectors" "block")))
    ("selector_query" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("selectors" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("sibling_selector" (:*unnamed* ("child_selector" "tag_name" "pseudo_element_selector" "nesting_selector" "universal_selector" "id_selector" "attribute_selector" "namespace_selector" "descendant_selector" "adjacent_sibling_selector" "string_value" "sibling_selector" "class_selector" "pseudo_class_selector")))
    ("stylesheet" (:*unnamed* ("rule_set" "media_statement" "supports_statement" "charset_statement" "import_statement" "at_rule" "declaration" "namespace_statement" "keyframes_statement")))
    ("supports_statement" (:*unnamed* ("selector_query" "feature_query" "binary_query" "unary_query" "keyword_query" "block" "parenthesized_query")))
    ("unary_query" (:*unnamed* ("selector_query" "feature_query" "binary_query" "unary_query" "keyword_query" "parenthesized_query")))
    ("at_keyword" (:*unnamed* nil))
    ("class_name" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("feature_name" (:*unnamed* nil))
    ("from" (:*unnamed* nil))
    ("function_name" (:*unnamed* nil))
    ("id_name" (:*unnamed* nil))
    ("important" (:*unnamed* nil))
    ("js_comment" (:*unnamed* nil))
    ("keyframes_name" (:*unnamed* nil))
    ("keyword_query" (:*unnamed* nil))
    ("namespace_name" (:*unnamed* nil))
    ("nesting_selector" (:*unnamed* nil))
    ("plain_value" (:*unnamed* nil))
    ("property_name" (:*unnamed* nil))
    ("tag_name" (:*unnamed* nil))
    ("to" (:*unnamed* nil))
    ("unit" (:*unnamed* nil))
    ))
;; END Production rules for css
;; START Inverse production rules for css
(defconst combobulate-rules-css-inverse
  '(("adjacent_sibling_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("arguments" ("pseudo_element_selector" "call_expression" "pseudo_class_selector"))
    ("at_keyword" ("postcss_statement" "at_rule" "keyframes_statement"))
    ("at_rule" ("stylesheet" "block"))
    ("attribute_name" ("attribute_selector"))
    ("attribute_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("binary_expression" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("binary_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("block" ("rule_set" "media_statement" "supports_statement" "keyframe_block" "at_rule"))
    ("call_expression" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value" "namespace_statement"))
    ("charset_statement" ("stylesheet" "block"))
    ("child_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("class_name" ("class_selector" "pseudo_class_selector"))
    ("class_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("color_value" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("declaration" ("stylesheet" "block"))
    ("descendant_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("feature_name" ("feature_query"))
    ("feature_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("float_value" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("from" ("keyframe_block"))
    ("function_name" ("call_expression"))
    ("grid_value" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("id_name" ("id_selector"))
    ("id_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("import_statement" ("stylesheet" "block"))
    ("important" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("integer_value" ("arguments" "feature_query" "grid_value" "charset_statement" "keyframe_block" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("keyframe_block" ("keyframe_block_list"))
    ("keyframe_block_list" ("keyframes_statement"))
    ("keyframes_name" ("keyframes_statement"))
    ("keyframes_statement" ("stylesheet" "block"))
    ("keyword_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("media_statement" ("stylesheet" "block"))
    ("namespace_name" ("namespace_statement"))
    ("namespace_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("namespace_statement" ("stylesheet" "block"))
    ("nesting_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("parenthesized_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("parenthesized_value" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("plain_value" ("arguments" "feature_query" "grid_value" "charset_statement" "import_statement" "attribute_selector" "postcss_statement" "declaration" "binary_expression" "parenthesized_value"))
    ("postcss_statement" ("block"))
    ("property_name" ("declaration"))
    ("pseudo_class_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("pseudo_element_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("rule_set" ("stylesheet" "block"))
    ("selector_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("selectors" ("rule_set"))
    ("sibling_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("string_value" ("attribute_selector" "binary_expression" "selectors" "class_selector" "child_selector" "grid_value" "selector_query" "feature_query" "charset_statement" "id_selector" "import_statement" "declaration" "namespace_selector" "descendant_selector" "namespace_statement" "pseudo_class_selector" "arguments" "pseudo_element_selector" "attribute_name" "postcss_statement" "adjacent_sibling_selector" "parenthesized_value" "sibling_selector"))
    ("supports_statement" ("stylesheet" "block"))
    ("tag_name" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    ("to" ("keyframe_block"))
    ("unary_query" ("media_statement" "supports_statement" "import_statement" "at_rule" "parenthesized_query" "unary_query" "binary_query"))
    ("unit" ("float_value" "integer_value"))
    ("universal_selector" ("child_selector" "arguments" "pseudo_element_selector" "attribute_name" "id_selector" "attribute_selector" "selector_query" "namespace_selector" "selectors" "descendant_selector" "adjacent_sibling_selector" "sibling_selector" "class_selector" "pseudo_class_selector"))
    )
  )
;; END Inverse production rules for css
;; START All node types in css
(defconst combobulate-rules-css-types
  '("adjacent_sibling_selector" "arguments" "at_keyword" "at_rule" "attribute_name" "attribute_selector" "binary_expression" "binary_query" "block" "call_expression" "charset_statement" "child_selector" "class_name" "class_selector" "color_value" "comment" "declaration" "descendant_selector" "feature_name" "feature_query" "float_value" "from" "function_name" "grid_value" "id_name" "id_selector" "import_statement" "important" "integer_value" "js_comment" "keyframe_block" "keyframe_block_list" "keyframes_name" "keyframes_statement" "keyword_query" "media_statement" "namespace_name" "namespace_selector" "namespace_statement" "nesting_selector" "parenthesized_query" "parenthesized_value" "plain_value" "postcss_statement" "property_name" "pseudo_class_selector" "pseudo_element_selector" "rule_set" "selector_query" "selectors" "sibling_selector" "string_value" "stylesheet" "supports_statement" "tag_name" "to" "unary_query" "unit" "universal_selector")
  )
;; END All node types in css

;; START Production rules for typescript
(defconst combobulate-rules-typescript
  '(("_primary_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("declaration" (:*unnamed* ("ambient_declaration" "interface_declaration" "internal_module" "module" "variable_declaration" "lexical_declaration" "function_signature" "generator_function_declaration" "abstract_class_declaration" "function_declaration" "class_declaration" "import_alias" "enum_declaration" "type_alias_declaration")))
    ("expression" (:*unnamed* ("type_assertion" "yield_expression" "as_expression" "binary_expression" "satisfies_expression" "augmented_assignment_expression" "new_expression" "internal_module" "assignment_expression" "primary_expression" "instantiation_expression" "update_expression" "await_expression" "glimmer_template" "ternary_expression" "unary_expression")))
    ("pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "rest_pattern" "non_null_expression" "subscript_expression")))
    ("primary_expression" (:*unnamed* ("member_expression" "array" "identifier" "string" "undefined" "parenthesized_expression" "arrow_function" "generator_function" "template_string" "call_expression" "class" "function" "subscript_expression" "false" "number" "regex" "super" "import" "object" "true" "this" "null" "meta_property" "non_null_expression")))
    ("statement" (:*unnamed* ("continue_statement" "for_statement" "with_statement" "export_statement" "import_statement" "if_statement" "do_statement" "declaration" "return_statement" "throw_statement" "for_in_statement" "while_statement" "empty_statement" "switch_statement" "expression_statement" "break_statement" "debugger_statement" "try_statement" "statement_block" "labeled_statement")))
    ("abstract_class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("abstract_method_signature" (:*unnamed* ("accessibility_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("ambient_declaration" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "declaration" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "statement_block" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type" "property_identifier")))
    ("arguments" (:*unnamed* ("spread_element" "expression")))
    ("array" (:*unnamed* ("spread_element" "expression")))
    ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
    ("array_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("as_expression" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "expression" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("asserts" (:*unnamed* ("this" "identifier" "type_predicate")))
    ("asserts_annotation" (:*unnamed* ("asserts")))
    ("assignment_expression" (:left ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "parenthesized_expression" "non_null_expression" "subscript_expression") :right ("expression")))
    ("assignment_pattern" (:left ("pattern") :right ("expression")))
    ("augmented_assignment_expression" (:left ("member_expression" "identifier" "parenthesized_expression" "non_null_expression" "subscript_expression") :operator nil :right ("expression")))
    ("await_expression" (:*unnamed* ("expression")))
    ("binary_expression" (:left ("expression") :operator nil :right ("expression")))
    ("break_statement" (:label ("statement_identifier")))
    ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :type_arguments ("type_arguments")))
    ("call_signature" (:parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("catch_clause" (:body ("statement_block") :parameter ("object_pattern" "identifier" "array_pattern") :type ("type_annotation")))
    ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("class_body" (:*unnamed* ("method_signature" "class_static_block" "abstract_method_signature" "public_field_definition" "method_definition" "decorator" "index_signature")))
    ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("class_heritage" (:*unnamed* ("extends_clause" "implements_clause")))
    ("class_static_block" (:body ("statement_block")))
    ("computed_property_name" (:*unnamed* ("expression")))
    ("conditional_type" (:alternative ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :consequence ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :left ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :right ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("constraint" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("construct_signature" (:parameters ("formal_parameters") :type ("type_annotation") :type_parameters ("type_parameters")))
    ("constructor_type" (:parameters ("formal_parameters") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :type_parameters ("type_parameters")))
    ("continue_statement" (:label ("statement_identifier")))
    ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression")))
    ("default_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("do_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("else_clause" (:*unnamed* ("statement")))
    ("enum_assignment" (:name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("enum_body" (:*unnamed* ("enum_assignment") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier")))
    ("enum_declaration" (:body ("enum_body") :name ("identifier")))
    ("export_clause" (:*unnamed* ("export_specifier")))
    ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier")))
    ("export_statement" (:*unnamed* ("namespace_export" "export_clause" "identifier" "expression") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
    ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("extends_clause" (:type_arguments ("type_arguments") :value ("expression")))
    ("extends_type_clause" (:type ("type_identifier" "generic_type" "nested_type_identifier")))
    ("finally_clause" (:body ("statement_block")))
    ("flow_maybe_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "parenthesized_expression" "non_null_expression" "subscript_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
    ("for_statement" (:body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("lexical_declaration" "expression_statement" "variable_declaration" "empty_statement")))
    ("formal_parameters" (:*unnamed* ("required_parameter" "optional_parameter")))
    ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_signature" (:name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("function_type" (:parameters ("formal_parameters") :return_type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "type_predicate" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "asserts" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :type_parameters ("type_parameters")))
    ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("generic_type" (:name ("type_identifier" "nested_type_identifier") :type_arguments ("type_arguments")))
    ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
    ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
    ("implements_clause" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("import_alias" (:*unnamed* ("identifier" "nested_identifier")))
    ("import_clause" (:*unnamed* ("namespace_import" "identifier" "named_imports")))
    ("import_require_clause" (:*unnamed* ("identifier") :source ("string")))
    ("import_specifier" (:alias ("identifier") :name ("string" "identifier")))
    ("import_statement" (:*unnamed* ("import_clause" "import_require_clause") :source ("string")))
    ("index_signature" (:*unnamed* ("mapped_type_clause") :index_type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :name ("identifier") :sign nil :type ("type_annotation" "opting_type_annotation" "omitting_type_annotation")))
    ("index_type_query" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("infer_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("instantiation_expression" (:*unnamed* ("expression") :function ("member_expression" "import" "identifier" "subscript_expression") :type_arguments ("type_arguments")))
    ("interface_declaration" (:*unnamed* ("extends_type_clause") :body ("object_type") :name ("type_identifier") :type_parameters ("type_parameters")))
    ("internal_module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier")))
    ("intersection_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_namespace_name" "jsx_element" "string" "jsx_self_closing_element" "property_identifier")))
    ("jsx_closing_element" (:name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_text" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
    ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
    ("jsx_namespace_name" (:*unnamed* ("identifier")))
    ("jsx_opening_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier") :type_arguments ("type_arguments")))
    ("jsx_self_closing_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier") :type_arguments ("type_arguments")))
    ("labeled_statement" (:body ("statement") :label ("statement_identifier")))
    ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
    ("literal_type" (:*unnamed* ("false" "string" "undefined" "null" "number" "true" "unary_expression")))
    ("lookup_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("mapped_type_clause" (:alias ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type") :name ("type_identifier") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier")))
    ("method_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :body ("statement_block") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("method_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters") :return_type ("type_annotation" "asserts_annotation" "type_predicate_annotation") :type_parameters ("type_parameters")))
    ("module" (:body ("statement_block") :name ("string" "identifier" "nested_identifier")))
    ("named_imports" (:*unnamed* ("import_specifier")))
    ("namespace_export" (:*unnamed* ("string" "identifier")))
    ("namespace_import" (:*unnamed* ("identifier")))
    ("nested_identifier" (:*unnamed* ("member_expression" "identifier" "property_identifier")))
    ("nested_type_identifier" (:module ("identifier" "nested_identifier") :name ("type_identifier")))
    ("new_expression" (:arguments ("arguments") :constructor ("primary_expression") :type_arguments ("type_arguments")))
    ("non_null_expression" (:*unnamed* ("expression")))
    ("object" (:*unnamed* ("method_definition" "pair" "spread_element" "shorthand_property_identifier")))
    ("object_assignment_pattern" (:left ("shorthand_property_identifier_pattern" "object_pattern" "array_pattern") :right ("expression")))
    ("object_pattern" (:*unnamed* ("shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern" "pair_pattern")))
    ("object_type" (:*unnamed* ("call_signature" "property_signature" "construct_signature" "export_statement" "method_signature" "index_signature")))
    ("omitting_type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("opting_type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("optional_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression")))
    ("optional_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("pair" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("pair_pattern" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("pattern" "assignment_pattern")))
    ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression") :type ("type_annotation")))
    ("parenthesized_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("program" (:*unnamed* ("hash_bang_line" "statement")))
    ("property_signature" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :type ("type_annotation")))
    ("public_field_definition" (:*unnamed* ("accessibility_modifier" "override_modifier") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :type ("type_annotation") :value ("expression")))
    ("readonly_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("regex" (:flags ("regex_flags") :pattern ("regex_pattern")))
    ("required_parameter" (:*unnamed* ("accessibility_modifier" "override_modifier") :decorator ("decorator") :name ("identifier" "rest_pattern") :pattern ("this" "pattern") :type ("type_annotation") :value ("expression")))
    ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "non_null_expression" "subscript_expression")))
    ("rest_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("satisfies_expression" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "expression" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression")))
    ("spread_element" (:*unnamed* ("expression")))
    ("statement_block" (:*unnamed* ("statement")))
    ("string" (:*unnamed* ("string_fragment" "escape_sequence")))
    ("subscript_expression" (:index ("sequence_expression" "predefined_type" "string" "expression" "number") :object ("expression") :optional_chain ("optional_chain")))
    ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
    ("switch_case" (:body ("statement") :value ("sequence_expression" "expression")))
    ("switch_default" (:body ("statement")))
    ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression")))
    ("template_literal_type" (:*unnamed* ("template_type")))
    ("template_string" (:*unnamed* ("template_substitution" "escape_sequence")))
    ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
    ("template_type" (:*unnamed* ("parenthesized_type" "type_query" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "conditional_type" "nested_type_identifier" "predefined_type" "existential_type" "union_type")))
    ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression")))
    ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
    ("tuple_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "optional_type" "tuple_type" "flow_maybe_type" "intersection_type" "rest_type" "generic_type" "lookup_type" "infer_type" "optional_parameter" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "required_parameter" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_alias_declaration" (:name ("type_identifier") :type_parameters ("type_parameters") :value ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_annotation" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_arguments" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_assertion" (:*unnamed* ("type_arguments" "expression")))
    ("type_parameter" (:constraint ("constraint") :name ("type_identifier") :value ("default_type")))
    ("type_parameters" (:*unnamed* ("type_parameter")))
    ("type_predicate" (:name ("this" "identifier") :type ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("type_predicate_annotation" (:*unnamed* ("type_predicate")))
    ("type_query" (:*unnamed* ("member_expression" "identifier" "call_expression" "instantiation_expression" "subscript_expression")))
    ("unary_expression" (:argument ("number" "expression") :operator nil))
    ("union_type" (:*unnamed* ("parenthesized_type" "type_query" "function_type" "tuple_type" "flow_maybe_type" "intersection_type" "generic_type" "lookup_type" "infer_type" "array_type" "type_identifier" "literal_type" "this_type" "object_type" "index_type_query" "template_literal_type" "constructor_type" "conditional_type" "nested_type_identifier" "readonly_type" "predefined_type" "existential_type" "union_type")))
    ("update_expression" (:argument ("expression") :operator nil))
    ("variable_declaration" (:*unnamed* ("variable_declarator")))
    ("variable_declarator" (:name ("object_pattern" "identifier" "array_pattern") :type ("type_annotation") :value ("expression")))
    ("while_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("with_statement" (:body ("statement") :object ("parenthesized_expression")))
    ("yield_expression" (:*unnamed* ("expression")))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("hash_bang_line" (:*unnamed* nil))
    ("null" (:*unnamed* nil))
    ("number" (:*unnamed* nil))
    ("private_property_identifier" (:*unnamed* nil))
    ("property_identifier" (:*unnamed* nil))
    ("regex_flags" (:*unnamed* nil))
    ("regex_pattern" (:*unnamed* nil))
    ("shorthand_property_identifier" (:*unnamed* nil))
    ("shorthand_property_identifier_pattern" (:*unnamed* nil))
    ("statement_identifier" (:*unnamed* nil))
    ("string_fragment" (:*unnamed* nil))
    ("super" (:*unnamed* nil))
    ("this" (:*unnamed* nil))
    ("this_type" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("type_identifier" (:*unnamed* nil))
    ("undefined" (:*unnamed* nil))
    ))
;; END Production rules for typescript
;; START Inverse production rules for typescript
(defconst combobulate-rules-typescript-inverse
  '(("abstract_class_declaration" ("declaration"))
    ("abstract_method_signature" ("class_body"))
    ("accessibility_modifier" ("abstract_method_signature" "public_field_definition" "method_definition" "required_parameter" "method_signature" "property_signature" "optional_parameter"))
    ("ambient_declaration" ("declaration"))
    ("arguments" ("new_expression" "call_expression"))
    ("array" ("primary_expression"))
    ("array_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("array_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("arrow_function" ("primary_expression"))
    ("as_expression" ("expression"))
    ("asserts" ("asserts_annotation" "function_type"))
    ("asserts_annotation" ("abstract_method_signature" "method_definition" "arrow_function" "function_signature" "generator_function" "generator_function_declaration" "function_declaration" "method_signature" "call_signature" "function"))
    ("assignment_expression" ("expression"))
    ("assignment_pattern" ("pair_pattern" "array_pattern"))
    ("augmented_assignment_expression" ("expression"))
    ("await_expression" ("expression"))
    ("binary_expression" ("expression"))
    ("break_statement" ("statement"))
    ("call_expression" ("primary_expression" "decorator" "type_query"))
    ("call_signature" ("object_type"))
    ("catch_clause" ("try_statement"))
    ("class" ("primary_expression"))
    ("class_body" ("abstract_class_declaration" "class_declaration" "class"))
    ("class_declaration" ("declaration"))
    ("class_heritage" ("abstract_class_declaration" "class_declaration" "class"))
    ("class_static_block" ("class_body"))
    ("computed_property_name" ("abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("conditional_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("constraint" ("type_parameter"))
    ("construct_signature" ("object_type"))
    ("constructor_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("continue_statement" ("statement"))
    ("debugger_statement" ("statement"))
    ("declaration" ("ambient_declaration" "export_statement" "statement"))
    ("decorator" ("optional_parameter" "required_parameter" "export_statement" "abstract_class_declaration" "class_declaration" "class_body" "class"))
    ("default_type" ("type_parameter"))
    ("do_statement" ("statement"))
    ("else_clause" ("if_statement"))
    ("empty_statement" ("for_statement" "statement"))
    ("enum_assignment" ("enum_body"))
    ("enum_body" ("enum_declaration"))
    ("enum_declaration" ("declaration"))
    ("escape_sequence" ("template_string" "string"))
    ("existential_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("export_clause" ("export_statement"))
    ("export_specifier" ("export_clause"))
    ("export_statement" ("object_type" "statement"))
    ("expression" ("jsx_expression" "member_expression" "sequence_expression" "parenthesized_expression" "spread_element" "binary_expression" "return_statement" "computed_property_name" "switch_case" "required_parameter" "instantiation_expression" "await_expression" "ternary_expression" "pair" "enum_assignment" "object_assignment_pattern" "non_null_expression" "variable_declarator" "template_substitution" "array" "type_assertion" "public_field_definition" "for_statement" "yield_expression" "export_statement" "arrow_function" "as_expression" "satisfies_expression" "call_expression" "augmented_assignment_expression" "extends_clause" "for_in_statement" "throw_statement" "optional_parameter" "subscript_expression" "assignment_expression" "arguments" "expression_statement" "update_expression" "assignment_pattern" "unary_expression"))
    ("expression_statement" ("for_statement" "statement"))
    ("extends_clause" ("class_heritage"))
    ("extends_type_clause" ("interface_declaration"))
    ("false" ("primary_expression" "literal_type"))
    ("finally_clause" ("try_statement"))
    ("flow_maybe_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("for_in_statement" ("statement"))
    ("for_statement" ("statement"))
    ("formal_parameters" ("abstract_method_signature" "function_type" "method_definition" "construct_signature" "arrow_function" "function_signature" "generator_function" "constructor_type" "function_declaration" "generator_function_declaration" "method_signature" "call_signature" "function"))
    ("function" ("primary_expression"))
    ("function_declaration" ("declaration"))
    ("function_signature" ("declaration"))
    ("function_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("generator_function" ("primary_expression"))
    ("generator_function_declaration" ("declaration"))
    ("generic_type" ("function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("glimmer_closing_tag" ("glimmer_template"))
    ("glimmer_opening_tag" ("glimmer_template"))
    ("glimmer_template" ("expression"))
    ("hash_bang_line" ("program"))
    ("identifier" ("member_expression" "type_query" "jsx_closing_element" "rest_pattern" "enum_declaration" "internal_module" "type_predicate" "namespace_import" "export_specifier" "module" "jsx_self_closing_element" "instantiation_expression" "required_parameter" "function_signature" "generator_function_declaration" "function_declaration" "variable_declarator" "import_clause" "catch_clause" "import_require_clause" "export_statement" "arrow_function" "generator_function" "namespace_export" "augmented_assignment_expression" "import_alias" "import_specifier" "for_in_statement" "function" "optional_parameter" "assignment_expression" "primary_expression" "jsx_namespace_name" "pattern" "decorator" "nested_identifier" "index_signature" "asserts" "nested_type_identifier" "jsx_opening_element"))
    ("if_statement" ("statement"))
    ("implements_clause" ("class_heritage"))
    ("import" ("primary_expression" "instantiation_expression"))
    ("import_alias" ("declaration"))
    ("import_clause" ("import_statement"))
    ("import_require_clause" ("import_statement"))
    ("import_specifier" ("named_imports"))
    ("import_statement" ("statement"))
    ("index_signature" ("object_type" "class_body"))
    ("index_type_query" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("infer_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("instantiation_expression" ("expression" "type_query"))
    ("interface_declaration" ("declaration"))
    ("internal_module" ("declaration" "expression"))
    ("intersection_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("jsx_attribute" ("jsx_self_closing_element" "jsx_opening_element"))
    ("jsx_closing_element" ("jsx_element"))
    ("jsx_element" ("jsx_attribute" "jsx_element"))
    ("jsx_expression" ("jsx_self_closing_element" "jsx_attribute" "jsx_element" "jsx_opening_element"))
    ("jsx_namespace_name" ("jsx_self_closing_element" "jsx_attribute" "jsx_closing_element" "jsx_opening_element"))
    ("jsx_opening_element" ("jsx_element"))
    ("jsx_self_closing_element" ("jsx_attribute" "jsx_element"))
    ("jsx_text" ("jsx_element"))
    ("labeled_statement" ("statement"))
    ("lexical_declaration" ("for_statement" "declaration"))
    ("literal_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("lookup_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("mapped_type_clause" ("index_signature"))
    ("member_expression" ("member_expression" "primary_expression" "pattern" "type_query" "jsx_self_closing_element" "instantiation_expression" "jsx_closing_element" "decorator" "nested_identifier" "rest_pattern" "augmented_assignment_expression" "jsx_opening_element" "for_in_statement" "assignment_expression"))
    ("meta_property" ("primary_expression"))
    ("method_definition" ("object" "class_body"))
    ("method_signature" ("object_type" "class_body"))
    ("module" ("declaration"))
    ("named_imports" ("import_clause"))
    ("namespace_export" ("export_statement"))
    ("namespace_import" ("import_clause"))
    ("nested_identifier" ("module" "internal_module" "nested_type_identifier" "import_alias"))
    ("nested_type_identifier" ("function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "generic_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("new_expression" ("expression"))
    ("non_null_expression" ("primary_expression" "pattern" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("null" ("primary_expression" "literal_type"))
    ("number" ("primary_expression" "literal_type" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature" "subscript_expression" "unary_expression"))
    ("object" ("primary_expression"))
    ("object_assignment_pattern" ("object_pattern"))
    ("object_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("object_type" ("interface_declaration" "function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("omitting_type_annotation" ("index_signature"))
    ("opting_type_annotation" ("index_signature"))
    ("optional_chain" ("member_expression" "subscript_expression"))
    ("optional_parameter" ("formal_parameters" "tuple_type"))
    ("optional_type" ("tuple_type"))
    ("override_modifier" ("public_field_definition" "method_definition" "required_parameter" "method_signature" "property_signature" "optional_parameter"))
    ("pair" ("object"))
    ("pair_pattern" ("object_pattern"))
    ("parenthesized_expression" ("primary_expression" "while_statement" "switch_statement" "with_statement" "if_statement" "do_statement" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("parenthesized_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("pattern" ("array_pattern" "required_parameter" "assignment_pattern" "pair_pattern" "optional_parameter"))
    ("predefined_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "subscript_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("primary_expression" ("new_expression" "expression"))
    ("private_property_identifier" ("member_expression" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("property_identifier" ("ambient_declaration" "jsx_attribute" "member_expression" "abstract_method_signature" "enum_body" "public_field_definition" "method_definition" "method_signature" "nested_identifier" "pair" "enum_assignment" "pair_pattern" "property_signature"))
    ("property_signature" ("object_type"))
    ("public_field_definition" ("class_body"))
    ("readonly_type" ("function_type" "implements_clause" "rest_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("regex" ("primary_expression"))
    ("regex_flags" ("regex"))
    ("regex_pattern" ("regex"))
    ("required_parameter" ("formal_parameters" "tuple_type"))
    ("rest_pattern" ("required_parameter" "pattern" "object_pattern"))
    ("rest_type" ("tuple_type"))
    ("return_statement" ("statement"))
    ("satisfies_expression" ("expression"))
    ("sequence_expression" ("jsx_expression" "sequence_expression" "parenthesized_expression" "for_statement" "throw_statement" "expression_statement" "return_statement" "switch_case" "for_in_statement" "template_substitution" "subscript_expression"))
    ("shorthand_property_identifier" ("object"))
    ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
    ("spread_element" ("array" "arguments" "jsx_expression" "object"))
    ("statement" ("switch_default" "while_statement" "for_statement" "statement_block" "with_statement" "if_statement" "do_statement" "else_clause" "labeled_statement" "program" "switch_case" "for_in_statement"))
    ("statement_block" ("ambient_declaration" "finally_clause" "method_definition" "module" "statement" "arrow_function" "generator_function" "generator_function_declaration" "try_statement" "function_declaration" "class_static_block" "internal_module" "function" "catch_clause"))
    ("statement_identifier" ("labeled_statement" "continue_statement" "break_statement"))
    ("string" ("enum_body" "method_signature" "internal_module" "export_specifier" "module" "method_definition" "pair" "enum_assignment" "property_signature" "jsx_attribute" "import_require_clause" "public_field_definition" "export_statement" "import_statement" "namespace_export" "import_specifier" "subscript_expression" "primary_expression" "literal_type" "abstract_method_signature" "pair_pattern"))
    ("string_fragment" ("string"))
    ("subscript_expression" ("primary_expression" "pattern" "type_query" "instantiation_expression" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("super" ("primary_expression"))
    ("switch_body" ("switch_statement"))
    ("switch_case" ("switch_body"))
    ("switch_default" ("switch_body"))
    ("switch_statement" ("statement"))
    ("template_literal_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("template_string" ("primary_expression" "call_expression"))
    ("template_substitution" ("template_string"))
    ("template_type" ("template_literal_type"))
    ("ternary_expression" ("expression"))
    ("this" ("primary_expression" "required_parameter" "type_predicate" "asserts" "optional_parameter"))
    ("this_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("throw_statement" ("statement"))
    ("true" ("primary_expression" "literal_type"))
    ("try_statement" ("statement"))
    ("tuple_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("type_alias_declaration" ("declaration"))
    ("type_annotation" ("parenthesized_expression" "method_signature" "call_signature" "method_definition" "required_parameter" "function_signature" "generator_function_declaration" "function_declaration" "property_signature" "variable_declarator" "catch_clause" "public_field_definition" "arrow_function" "generator_function" "optional_parameter" "function" "abstract_method_signature" "construct_signature" "index_signature"))
    ("type_arguments" ("type_assertion" "jsx_self_closing_element" "instantiation_expression" "generic_type" "call_expression" "jsx_opening_element" "extends_clause" "new_expression"))
    ("type_assertion" ("expression"))
    ("type_identifier" ("interface_declaration" "function_type" "extends_type_clause" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "generic_type" "class_declaration" "tuple_type" "lookup_type" "default_type" "infer_type" "class" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "abstract_class_declaration" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "nested_type_identifier" "readonly_type" "type_parameter"))
    ("type_parameter" ("type_parameters"))
    ("type_parameters" ("interface_declaration" "method_signature" "abstract_method_signature" "function_type" "method_definition" "construct_signature" "arrow_function" "function_signature" "generator_function" "abstract_class_declaration" "constructor_type" "function_declaration" "class_declaration" "function" "generator_function_declaration" "call_signature" "class" "type_alias_declaration"))
    ("type_predicate" ("type_predicate_annotation" "asserts" "function_type"))
    ("type_predicate_annotation" ("abstract_method_signature" "method_definition" "arrow_function" "function_signature" "generator_function" "generator_function_declaration" "function_declaration" "method_signature" "call_signature" "function"))
    ("type_query" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("unary_expression" ("literal_type" "expression"))
    ("undefined" ("primary_expression" "literal_type" "pattern" "rest_pattern" "for_in_statement" "assignment_expression"))
    ("union_type" ("function_type" "implements_clause" "rest_type" "flow_maybe_type" "_primary_type" "intersection_type" "tuple_type" "lookup_type" "default_type" "infer_type" "type_predicate" "array_type" "index_type_query" "mapped_type_clause" "omitting_type_annotation" "constructor_type" "type_arguments" "union_type" "ambient_declaration" "constraint" "parenthesized_type" "template_type" "type_annotation" "optional_type" "opting_type_annotation" "as_expression" "satisfies_expression" "type_alias_declaration" "index_signature" "conditional_type" "readonly_type"))
    ("update_expression" ("expression"))
    ("variable_declaration" ("for_statement" "declaration"))
    ("variable_declarator" ("variable_declaration" "lexical_declaration"))
    ("while_statement" ("statement"))
    ("with_statement" ("statement"))
    ("yield_expression" ("expression"))
    )
  )
;; END Inverse production rules for typescript
;; START All node types in typescript
(defconst combobulate-rules-typescript-types
  '("_primary_type" "abstract_class_declaration" "abstract_method_signature" "accessibility_modifier" "ambient_declaration" "arguments" "array" "array_pattern" "array_type" "arrow_function" "as_expression" "asserts" "asserts_annotation" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "call_signature" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "conditional_type" "constraint" "construct_signature" "constructor_type" "continue_statement" "debugger_statement" "declaration" "decorator" "default_type" "do_statement" "else_clause" "empty_statement" "enum_assignment" "enum_body" "enum_declaration" "escape_sequence" "existential_type" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "extends_clause" "extends_type_clause" "false" "finally_clause" "flow_maybe_type" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "function_signature" "function_type" "generator_function" "generator_function_declaration" "generic_type" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "implements_clause" "import" "import_alias" "import_clause" "import_require_clause" "import_specifier" "import_statement" "index_signature" "index_type_query" "infer_type" "instantiation_expression" "interface_declaration" "internal_module" "intersection_type" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "literal_type" "lookup_type" "mapped_type_clause" "member_expression" "meta_property" "method_definition" "method_signature" "module" "named_imports" "namespace_export" "namespace_import" "nested_identifier" "nested_type_identifier" "new_expression" "non_null_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "object_type" "omitting_type_annotation" "opting_type_annotation" "optional_chain" "optional_parameter" "optional_type" "override_modifier" "pair" "pair_pattern" "parenthesized_expression" "parenthesized_type" "pattern" "predefined_type" "primary_expression" "private_property_identifier" "program" "property_identifier" "property_signature" "public_field_definition" "readonly_type" "regex" "regex_flags" "regex_pattern" "required_parameter" "rest_pattern" "rest_type" "return_statement" "satisfies_expression" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_literal_type" "template_string" "template_substitution" "template_type" "ternary_expression" "this" "this_type" "throw_statement" "true" "try_statement" "tuple_type" "type_alias_declaration" "type_annotation" "type_arguments" "type_assertion" "type_identifier" "type_parameter" "type_parameters" "type_predicate" "type_predicate_annotation" "type_query" "unary_expression" "undefined" "union_type" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
  )
;; END All node types in typescript

;; START Production rules for javascript
(defconst combobulate-rules-javascript
  '(("declaration" (:*unnamed* ("function_declaration" "class_declaration" "variable_declaration" "lexical_declaration" "generator_function_declaration")))
    ("expression" (:*unnamed* ("primary_expression" "jsx_element" "jsx_self_closing_element" "unary_expression" "yield_expression" "update_expression" "await_expression" "glimmer_template" "ternary_expression" "binary_expression" "augmented_assignment_expression" "new_expression" "assignment_expression")))
    ("pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "rest_pattern" "object_pattern" "array_pattern" "subscript_expression")))
    ("primary_expression" (:*unnamed* ("member_expression" "array" "identifier" "string" "undefined" "parenthesized_expression" "arrow_function" "generator_function" "template_string" "call_expression" "class" "function" "subscript_expression" "false" "number" "regex" "super" "object" "true" "this" "null" "meta_property" "import")))
    ("statement" (:*unnamed* ("continue_statement" "for_statement" "with_statement" "export_statement" "import_statement" "if_statement" "do_statement" "declaration" "return_statement" "throw_statement" "for_in_statement" "while_statement" "empty_statement" "switch_statement" "expression_statement" "break_statement" "debugger_statement" "try_statement" "statement_block" "labeled_statement")))
    ("arguments" (:*unnamed* ("spread_element" "expression")))
    ("array" (:*unnamed* ("spread_element" "expression")))
    ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
    ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters")))
    ("assignment_expression" (:left ("member_expression" "identifier" "undefined" "object_pattern" "parenthesized_expression" "array_pattern" "subscript_expression") :right ("expression")))
    ("assignment_pattern" (:left ("pattern") :right ("expression")))
    ("augmented_assignment_expression" (:left ("member_expression" "parenthesized_expression" "identifier" "subscript_expression") :operator nil :right ("expression")))
    ("await_expression" (:*unnamed* ("expression")))
    ("binary_expression" (:left ("private_property_identifier" "expression") :operator nil :right ("expression")))
    ("break_statement" (:label ("statement_identifier")))
    ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :optional_chain ("optional_chain")))
    ("catch_clause" (:body ("statement_block") :parameter ("object_pattern" "identifier" "array_pattern")))
    ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
    ("class_body" (:member ("field_definition" "method_definition" "class_static_block") :template ("glimmer_template")))
    ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
    ("class_heritage" (:*unnamed* ("expression")))
    ("class_static_block" (:body ("statement_block")))
    ("computed_property_name" (:*unnamed* ("expression")))
    ("continue_statement" (:label ("statement_identifier")))
    ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression")))
    ("do_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("else_clause" (:*unnamed* ("statement")))
    ("export_clause" (:*unnamed* ("export_specifier")))
    ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier")))
    ("export_statement" (:*unnamed* ("export_clause" "namespace_export") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
    ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("field_definition" (:decorator ("decorator") :property ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("finally_clause" (:body ("statement_block")))
    ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "undefined" "object_pattern" "parenthesized_expression" "array_pattern" "subscript_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
    ("for_statement" (:body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("lexical_declaration" "expression_statement" "variable_declaration" "empty_statement")))
    ("formal_parameters" (:*unnamed* ("pattern" "assignment_pattern")))
    ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
    ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
    ("import_clause" (:*unnamed* ("namespace_import" "identifier" "named_imports")))
    ("import_specifier" (:alias ("identifier") :name ("string" "identifier")))
    ("import_statement" (:*unnamed* ("import_clause") :source ("string")))
    ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_namespace_name" "jsx_element" "string" "jsx_self_closing_element" "property_identifier")))
    ("jsx_closing_element" (:name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_text" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
    ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
    ("jsx_namespace_name" (:*unnamed* ("identifier")))
    ("jsx_opening_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_self_closing_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier")))
    ("labeled_statement" (:body ("statement") :label ("statement_identifier")))
    ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
    ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier")))
    ("method_definition" (:body ("statement_block") :decorator ("decorator") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters")))
    ("named_imports" (:*unnamed* ("import_specifier")))
    ("namespace_export" (:*unnamed* ("string" "identifier")))
    ("namespace_import" (:*unnamed* ("identifier")))
    ("new_expression" (:arguments ("arguments") :constructor ("primary_expression" "new_expression")))
    ("object" (:*unnamed* ("method_definition" "pair" "spread_element" "shorthand_property_identifier")))
    ("object_assignment_pattern" (:left ("shorthand_property_identifier_pattern" "object_pattern" "array_pattern") :right ("expression")))
    ("object_pattern" (:*unnamed* ("shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern" "pair_pattern")))
    ("pair" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("pair_pattern" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("pattern" "assignment_pattern")))
    ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression")))
    ("program" (:*unnamed* ("hash_bang_line" "statement")))
    ("regex" (:flags ("regex_flags") :pattern ("regex_pattern")))
    ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "subscript_expression")))
    ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression")))
    ("spread_element" (:*unnamed* ("expression")))
    ("statement_block" (:*unnamed* ("statement")))
    ("string" (:*unnamed* ("string_fragment" "escape_sequence")))
    ("subscript_expression" (:index ("sequence_expression" "expression") :object ("expression") :optional_chain ("optional_chain")))
    ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
    ("switch_case" (:body ("statement") :value ("sequence_expression" "expression")))
    ("switch_default" (:body ("statement")))
    ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression")))
    ("template_string" (:*unnamed* ("template_substitution" "escape_sequence")))
    ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
    ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression")))
    ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
    ("unary_expression" (:argument ("expression") :operator nil))
    ("update_expression" (:argument ("expression") :operator nil))
    ("variable_declaration" (:*unnamed* ("variable_declarator")))
    ("variable_declarator" (:name ("object_pattern" "identifier" "array_pattern") :value ("expression")))
    ("while_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("with_statement" (:body ("statement") :object ("parenthesized_expression")))
    ("yield_expression" (:*unnamed* ("expression")))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("hash_bang_line" (:*unnamed* nil))
    ("identifier" (:*unnamed* nil))
    ("null" (:*unnamed* nil))
    ("number" (:*unnamed* nil))
    ("optional_chain" (:*unnamed* nil))
    ("private_property_identifier" (:*unnamed* nil))
    ("property_identifier" (:*unnamed* nil))
    ("regex_flags" (:*unnamed* nil))
    ("regex_pattern" (:*unnamed* nil))
    ("shorthand_property_identifier" (:*unnamed* nil))
    ("shorthand_property_identifier_pattern" (:*unnamed* nil))
    ("statement_identifier" (:*unnamed* nil))
    ("string_fragment" (:*unnamed* nil))
    ("super" (:*unnamed* nil))
    ("this" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("undefined" (:*unnamed* nil))
    ))
;; END Production rules for javascript
;; START Inverse production rules for javascript
(defconst combobulate-rules-javascript-inverse
  '(("arguments" ("new_expression" "call_expression"))
    ("array" ("primary_expression"))
    ("array_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("arrow_function" ("primary_expression"))
    ("assignment_expression" ("expression"))
    ("assignment_pattern" ("formal_parameters" "pair_pattern" "array_pattern"))
    ("augmented_assignment_expression" ("expression"))
    ("await_expression" ("expression"))
    ("binary_expression" ("expression"))
    ("break_statement" ("statement"))
    ("call_expression" ("primary_expression" "decorator"))
    ("catch_clause" ("try_statement"))
    ("class" ("primary_expression"))
    ("class_body" ("class_declaration" "class"))
    ("class_declaration" ("declaration"))
    ("class_heritage" ("class_declaration" "class"))
    ("class_static_block" ("class_body"))
    ("computed_property_name" ("field_definition" "pair_pattern" "pair" "method_definition"))
    ("continue_statement" ("statement"))
    ("debugger_statement" ("statement"))
    ("declaration" ("export_statement" "statement"))
    ("decorator" ("method_definition" "export_statement" "class_declaration" "field_definition" "class"))
    ("do_statement" ("statement"))
    ("else_clause" ("if_statement"))
    ("empty_statement" ("for_statement" "statement"))
    ("escape_sequence" ("template_string" "string"))
    ("export_clause" ("export_statement"))
    ("export_specifier" ("export_clause"))
    ("export_statement" ("statement"))
    ("expression" ("jsx_expression" "member_expression" "sequence_expression" "parenthesized_expression" "class_heritage" "spread_element" "binary_expression" "return_statement" "computed_property_name" "field_definition" "switch_case" "await_expression" "ternary_expression" "pair" "object_assignment_pattern" "variable_declarator" "template_substitution" "array" "for_statement" "yield_expression" "export_statement" "arrow_function" "call_expression" "augmented_assignment_expression" "for_in_statement" "throw_statement" "subscript_expression" "assignment_expression" "arguments" "expression_statement" "update_expression" "assignment_pattern" "unary_expression"))
    ("expression_statement" ("for_statement" "statement"))
    ("false" ("primary_expression"))
    ("field_definition" ("class_body"))
    ("finally_clause" ("try_statement"))
    ("for_in_statement" ("statement"))
    ("for_statement" ("statement"))
    ("formal_parameters" ("method_definition" "arrow_function" "generator_function_declaration" "generator_function" "function_declaration" "function"))
    ("function" ("primary_expression"))
    ("function_declaration" ("declaration"))
    ("generator_function" ("primary_expression"))
    ("generator_function_declaration" ("declaration"))
    ("glimmer_closing_tag" ("glimmer_template"))
    ("glimmer_opening_tag" ("glimmer_template"))
    ("glimmer_template" ("expression" "class_body"))
    ("hash_bang_line" ("program"))
    ("identifier" ("member_expression" "jsx_closing_element" "class_declaration" "rest_pattern" "class" "namespace_import" "export_specifier" "jsx_self_closing_element" "generator_function_declaration" "function_declaration" "variable_declarator" "import_clause" "catch_clause" "arrow_function" "generator_function" "namespace_export" "augmented_assignment_expression" "import_specifier" "for_in_statement" "function" "assignment_expression" "primary_expression" "jsx_namespace_name" "pattern" "decorator" "jsx_opening_element"))
    ("if_statement" ("statement"))
    ("import" ("primary_expression"))
    ("import_clause" ("import_statement"))
    ("import_specifier" ("named_imports"))
    ("import_statement" ("statement"))
    ("jsx_attribute" ("jsx_self_closing_element" "jsx_opening_element"))
    ("jsx_closing_element" ("jsx_element"))
    ("jsx_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_expression" ("jsx_self_closing_element" "jsx_attribute" "jsx_element" "jsx_opening_element"))
    ("jsx_namespace_name" ("jsx_self_closing_element" "jsx_attribute" "jsx_closing_element" "jsx_opening_element"))
    ("jsx_opening_element" ("jsx_element"))
    ("jsx_self_closing_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_text" ("jsx_element"))
    ("labeled_statement" ("statement"))
    ("lexical_declaration" ("for_statement" "declaration"))
    ("member_expression" ("member_expression" "primary_expression" "pattern" "jsx_self_closing_element" "jsx_closing_element" "decorator" "rest_pattern" "augmented_assignment_expression" "jsx_opening_element" "for_in_statement" "assignment_expression"))
    ("meta_property" ("primary_expression"))
    ("method_definition" ("object" "class_body"))
    ("named_imports" ("import_clause"))
    ("namespace_export" ("export_statement"))
    ("namespace_import" ("import_clause"))
    ("new_expression" ("new_expression" "expression"))
    ("null" ("primary_expression"))
    ("number" ("primary_expression" "method_definition" "pair" "pair_pattern" "field_definition"))
    ("object" ("primary_expression"))
    ("object_assignment_pattern" ("object_pattern"))
    ("object_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("optional_chain" ("member_expression" "call_expression" "subscript_expression"))
    ("pair" ("object"))
    ("pair_pattern" ("object_pattern"))
    ("parenthesized_expression" ("primary_expression" "while_statement" "switch_statement" "with_statement" "if_statement" "do_statement" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("pattern" ("formal_parameters" "assignment_pattern" "pair_pattern" "array_pattern"))
    ("primary_expression" ("new_expression" "expression"))
    ("private_property_identifier" ("member_expression" "method_definition" "pair" "binary_expression" "pair_pattern" "field_definition"))
    ("property_identifier" ("member_expression" "jsx_attribute" "method_definition" "pair" "pair_pattern" "field_definition"))
    ("regex" ("primary_expression"))
    ("regex_flags" ("regex"))
    ("regex_pattern" ("regex"))
    ("rest_pattern" ("pattern" "object_pattern"))
    ("return_statement" ("statement"))
    ("sequence_expression" ("jsx_expression" "sequence_expression" "parenthesized_expression" "for_statement" "throw_statement" "expression_statement" "return_statement" "switch_case" "for_in_statement" "template_substitution" "subscript_expression"))
    ("shorthand_property_identifier" ("object"))
    ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
    ("spread_element" ("array" "arguments" "jsx_expression" "object"))
    ("statement" ("switch_default" "while_statement" "for_statement" "statement_block" "with_statement" "if_statement" "do_statement" "else_clause" "labeled_statement" "program" "switch_case" "for_in_statement"))
    ("statement_block" ("finally_clause" "method_definition" "statement" "arrow_function" "generator_function" "generator_function_declaration" "try_statement" "function_declaration" "class_static_block" "function" "catch_clause"))
    ("statement_identifier" ("labeled_statement" "continue_statement" "break_statement"))
    ("string" ("primary_expression" "jsx_attribute" "export_specifier" "method_definition" "export_statement" "import_statement" "pair" "namespace_export" "pair_pattern" "import_specifier" "field_definition"))
    ("string_fragment" ("string"))
    ("subscript_expression" ("primary_expression" "pattern" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("super" ("primary_expression"))
    ("switch_body" ("switch_statement"))
    ("switch_case" ("switch_body"))
    ("switch_default" ("switch_body"))
    ("switch_statement" ("statement"))
    ("template_string" ("primary_expression" "call_expression"))
    ("template_substitution" ("template_string"))
    ("ternary_expression" ("expression"))
    ("this" ("primary_expression"))
    ("throw_statement" ("statement"))
    ("true" ("primary_expression"))
    ("try_statement" ("statement"))
    ("unary_expression" ("expression"))
    ("undefined" ("primary_expression" "pattern" "rest_pattern" "for_in_statement" "assignment_expression"))
    ("update_expression" ("expression"))
    ("variable_declaration" ("for_statement" "declaration"))
    ("variable_declarator" ("variable_declaration" "lexical_declaration"))
    ("while_statement" ("statement"))
    ("with_statement" ("statement"))
    ("yield_expression" ("expression"))
    )
  )
;; END Inverse production rules for javascript
;; START All node types in javascript
(defconst combobulate-rules-javascript-types
  '("arguments" "array" "array_pattern" "arrow_function" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "continue_statement" "debugger_statement" "declaration" "decorator" "do_statement" "else_clause" "empty_statement" "escape_sequence" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "false" "field_definition" "finally_clause" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "generator_function" "generator_function_declaration" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "import" "import_clause" "import_specifier" "import_statement" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "member_expression" "meta_property" "method_definition" "named_imports" "namespace_export" "namespace_import" "new_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "optional_chain" "pair" "pair_pattern" "parenthesized_expression" "pattern" "primary_expression" "private_property_identifier" "program" "property_identifier" "regex" "regex_flags" "regex_pattern" "rest_pattern" "return_statement" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_string" "template_substitution" "ternary_expression" "this" "throw_statement" "true" "try_statement" "unary_expression" "undefined" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
  )
;; END All node types in javascript

;; START Production rules for jsx
(defconst combobulate-rules-jsx
  '(("declaration" (:*unnamed* ("function_declaration" "class_declaration" "variable_declaration" "lexical_declaration" "generator_function_declaration")))
    ("expression" (:*unnamed* ("primary_expression" "jsx_element" "jsx_self_closing_element" "unary_expression" "yield_expression" "update_expression" "await_expression" "glimmer_template" "ternary_expression" "binary_expression" "augmented_assignment_expression" "new_expression" "assignment_expression")))
    ("pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "rest_pattern" "object_pattern" "array_pattern" "subscript_expression")))
    ("primary_expression" (:*unnamed* ("member_expression" "array" "identifier" "string" "undefined" "parenthesized_expression" "arrow_function" "generator_function" "template_string" "call_expression" "class" "function" "subscript_expression" "false" "number" "regex" "super" "object" "true" "this" "null" "meta_property" "import")))
    ("statement" (:*unnamed* ("continue_statement" "for_statement" "with_statement" "export_statement" "import_statement" "if_statement" "do_statement" "declaration" "return_statement" "throw_statement" "for_in_statement" "while_statement" "empty_statement" "switch_statement" "expression_statement" "break_statement" "debugger_statement" "try_statement" "statement_block" "labeled_statement")))
    ("arguments" (:*unnamed* ("spread_element" "expression")))
    ("array" (:*unnamed* ("spread_element" "expression")))
    ("array_pattern" (:*unnamed* ("pattern" "assignment_pattern")))
    ("arrow_function" (:body ("statement_block" "expression") :parameter ("identifier") :parameters ("formal_parameters")))
    ("assignment_expression" (:left ("member_expression" "identifier" "undefined" "object_pattern" "parenthesized_expression" "array_pattern" "subscript_expression") :right ("expression")))
    ("assignment_pattern" (:left ("pattern") :right ("expression")))
    ("augmented_assignment_expression" (:left ("member_expression" "parenthesized_expression" "identifier" "subscript_expression") :operator nil :right ("expression")))
    ("await_expression" (:*unnamed* ("expression")))
    ("binary_expression" (:left ("private_property_identifier" "expression") :operator nil :right ("expression")))
    ("break_statement" (:label ("statement_identifier")))
    ("call_expression" (:arguments ("arguments" "template_string") :function ("expression") :optional_chain ("optional_chain")))
    ("catch_clause" (:body ("statement_block") :parameter ("object_pattern" "identifier" "array_pattern")))
    ("class" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
    ("class_body" (:member ("field_definition" "method_definition" "class_static_block") :template ("glimmer_template")))
    ("class_declaration" (:*unnamed* ("class_heritage") :body ("class_body") :decorator ("decorator") :name ("identifier")))
    ("class_heritage" (:*unnamed* ("expression")))
    ("class_static_block" (:body ("statement_block")))
    ("computed_property_name" (:*unnamed* ("expression")))
    ("continue_statement" (:label ("statement_identifier")))
    ("decorator" (:*unnamed* ("member_expression" "identifier" "call_expression")))
    ("do_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("else_clause" (:*unnamed* ("statement")))
    ("export_clause" (:*unnamed* ("export_specifier")))
    ("export_specifier" (:alias ("string" "identifier") :name ("string" "identifier")))
    ("export_statement" (:*unnamed* ("export_clause" "namespace_export") :declaration ("declaration") :decorator ("decorator") :source ("string") :value ("expression")))
    ("expression_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("field_definition" (:decorator ("decorator") :property ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("finally_clause" (:body ("statement_block")))
    ("for_in_statement" (:body ("statement") :kind nil :left ("member_expression" "identifier" "undefined" "object_pattern" "parenthesized_expression" "array_pattern" "subscript_expression") :operator nil :right ("sequence_expression" "expression") :value ("expression")))
    ("for_statement" (:body ("statement") :condition ("expression_statement" "empty_statement") :increment ("sequence_expression" "expression") :initializer ("lexical_declaration" "expression_statement" "variable_declaration" "empty_statement")))
    ("formal_parameters" (:*unnamed* ("pattern" "assignment_pattern")))
    ("function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("generator_function" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("generator_function_declaration" (:body ("statement_block") :name ("identifier") :parameters ("formal_parameters")))
    ("glimmer_template" (:close_tag ("glimmer_closing_tag") :open_tag ("glimmer_opening_tag")))
    ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("statement")))
    ("import_clause" (:*unnamed* ("namespace_import" "identifier" "named_imports")))
    ("import_specifier" (:alias ("identifier") :name ("string" "identifier")))
    ("import_statement" (:*unnamed* ("import_clause") :source ("string")))
    ("jsx_attribute" (:*unnamed* ("jsx_expression" "jsx_namespace_name" "jsx_element" "string" "jsx_self_closing_element" "property_identifier")))
    ("jsx_closing_element" (:name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_element" (:*unnamed* ("jsx_expression" "jsx_element" "jsx_text" "jsx_self_closing_element") :close_tag ("jsx_closing_element") :open_tag ("jsx_opening_element")))
    ("jsx_expression" (:*unnamed* ("sequence_expression" "spread_element" "expression")))
    ("jsx_namespace_name" (:*unnamed* ("identifier")))
    ("jsx_opening_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier")))
    ("jsx_self_closing_element" (:attribute ("jsx_expression" "jsx_attribute") :name ("member_expression" "jsx_namespace_name" "identifier")))
    ("labeled_statement" (:body ("statement") :label ("statement_identifier")))
    ("lexical_declaration" (:*unnamed* ("variable_declarator") :kind nil))
    ("member_expression" (:*unnamed* ("member_expression" "identifier" "property_identifier") :object ("expression") :optional_chain ("optional_chain") :property ("private_property_identifier" "property_identifier")))
    ("method_definition" (:body ("statement_block") :decorator ("decorator") :name ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :parameters ("formal_parameters")))
    ("named_imports" (:*unnamed* ("import_specifier")))
    ("namespace_export" (:*unnamed* ("string" "identifier")))
    ("namespace_import" (:*unnamed* ("identifier")))
    ("new_expression" (:arguments ("arguments") :constructor ("primary_expression" "new_expression")))
    ("object" (:*unnamed* ("method_definition" "pair" "spread_element" "shorthand_property_identifier")))
    ("object_assignment_pattern" (:left ("shorthand_property_identifier_pattern" "object_pattern" "array_pattern") :right ("expression")))
    ("object_pattern" (:*unnamed* ("shorthand_property_identifier_pattern" "object_assignment_pattern" "rest_pattern" "pair_pattern")))
    ("pair" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("expression")))
    ("pair_pattern" (:key ("string" "computed_property_name" "number" "private_property_identifier" "property_identifier") :value ("pattern" "assignment_pattern")))
    ("parenthesized_expression" (:*unnamed* ("sequence_expression" "expression")))
    ("program" (:*unnamed* ("hash_bang_line" "statement")))
    ("regex" (:flags ("regex_flags") :pattern ("regex_pattern")))
    ("rest_pattern" (:*unnamed* ("member_expression" "identifier" "undefined" "object_pattern" "array_pattern" "subscript_expression")))
    ("return_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("sequence_expression" (:left ("expression") :right ("sequence_expression" "expression")))
    ("spread_element" (:*unnamed* ("expression")))
    ("statement_block" (:*unnamed* ("statement")))
    ("string" (:*unnamed* ("string_fragment" "escape_sequence")))
    ("subscript_expression" (:index ("sequence_expression" "expression") :object ("expression") :optional_chain ("optional_chain")))
    ("switch_body" (:*unnamed* ("switch_case" "switch_default")))
    ("switch_case" (:body ("statement") :value ("sequence_expression" "expression")))
    ("switch_default" (:body ("statement")))
    ("switch_statement" (:body ("switch_body") :value ("parenthesized_expression")))
    ("template_string" (:*unnamed* ("template_substitution" "escape_sequence")))
    ("template_substitution" (:*unnamed* ("sequence_expression" "expression")))
    ("ternary_expression" (:alternative ("expression") :condition ("expression") :consequence ("expression")))
    ("throw_statement" (:*unnamed* ("sequence_expression" "expression")))
    ("try_statement" (:body ("statement_block") :finalizer ("finally_clause") :handler ("catch_clause")))
    ("unary_expression" (:argument ("expression") :operator nil))
    ("update_expression" (:argument ("expression") :operator nil))
    ("variable_declaration" (:*unnamed* ("variable_declarator")))
    ("variable_declarator" (:name ("object_pattern" "identifier" "array_pattern") :value ("expression")))
    ("while_statement" (:body ("statement") :condition ("parenthesized_expression")))
    ("with_statement" (:body ("statement") :object ("parenthesized_expression")))
    ("yield_expression" (:*unnamed* ("expression")))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("hash_bang_line" (:*unnamed* nil))
    ("identifier" (:*unnamed* nil))
    ("null" (:*unnamed* nil))
    ("number" (:*unnamed* nil))
    ("optional_chain" (:*unnamed* nil))
    ("private_property_identifier" (:*unnamed* nil))
    ("property_identifier" (:*unnamed* nil))
    ("regex_flags" (:*unnamed* nil))
    ("regex_pattern" (:*unnamed* nil))
    ("shorthand_property_identifier" (:*unnamed* nil))
    ("shorthand_property_identifier_pattern" (:*unnamed* nil))
    ("statement_identifier" (:*unnamed* nil))
    ("string_fragment" (:*unnamed* nil))
    ("super" (:*unnamed* nil))
    ("this" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("undefined" (:*unnamed* nil))
    ))
;; END Production rules for jsx
;; START Inverse production rules for jsx
(defconst combobulate-rules-jsx-inverse
  '(("arguments" ("new_expression" "call_expression"))
    ("array" ("primary_expression"))
    ("array_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("arrow_function" ("primary_expression"))
    ("assignment_expression" ("expression"))
    ("assignment_pattern" ("formal_parameters" "pair_pattern" "array_pattern"))
    ("augmented_assignment_expression" ("expression"))
    ("await_expression" ("expression"))
    ("binary_expression" ("expression"))
    ("break_statement" ("statement"))
    ("call_expression" ("primary_expression" "decorator"))
    ("catch_clause" ("try_statement"))
    ("class" ("primary_expression"))
    ("class_body" ("class_declaration" "class"))
    ("class_declaration" ("declaration"))
    ("class_heritage" ("class_declaration" "class"))
    ("class_static_block" ("class_body"))
    ("computed_property_name" ("field_definition" "pair_pattern" "pair" "method_definition"))
    ("continue_statement" ("statement"))
    ("debugger_statement" ("statement"))
    ("declaration" ("export_statement" "statement"))
    ("decorator" ("method_definition" "export_statement" "class_declaration" "field_definition" "class"))
    ("do_statement" ("statement"))
    ("else_clause" ("if_statement"))
    ("empty_statement" ("for_statement" "statement"))
    ("escape_sequence" ("template_string" "string"))
    ("export_clause" ("export_statement"))
    ("export_specifier" ("export_clause"))
    ("export_statement" ("statement"))
    ("expression" ("jsx_expression" "member_expression" "sequence_expression" "parenthesized_expression" "class_heritage" "spread_element" "binary_expression" "return_statement" "computed_property_name" "field_definition" "switch_case" "await_expression" "ternary_expression" "pair" "object_assignment_pattern" "variable_declarator" "template_substitution" "array" "for_statement" "yield_expression" "export_statement" "arrow_function" "call_expression" "augmented_assignment_expression" "for_in_statement" "throw_statement" "subscript_expression" "assignment_expression" "arguments" "expression_statement" "update_expression" "assignment_pattern" "unary_expression"))
    ("expression_statement" ("for_statement" "statement"))
    ("false" ("primary_expression"))
    ("field_definition" ("class_body"))
    ("finally_clause" ("try_statement"))
    ("for_in_statement" ("statement"))
    ("for_statement" ("statement"))
    ("formal_parameters" ("method_definition" "arrow_function" "generator_function_declaration" "generator_function" "function_declaration" "function"))
    ("function" ("primary_expression"))
    ("function_declaration" ("declaration"))
    ("generator_function" ("primary_expression"))
    ("generator_function_declaration" ("declaration"))
    ("glimmer_closing_tag" ("glimmer_template"))
    ("glimmer_opening_tag" ("glimmer_template"))
    ("glimmer_template" ("expression" "class_body"))
    ("hash_bang_line" ("program"))
    ("identifier" ("member_expression" "jsx_closing_element" "class_declaration" "rest_pattern" "class" "namespace_import" "export_specifier" "jsx_self_closing_element" "generator_function_declaration" "function_declaration" "variable_declarator" "import_clause" "catch_clause" "arrow_function" "generator_function" "namespace_export" "augmented_assignment_expression" "import_specifier" "for_in_statement" "function" "assignment_expression" "primary_expression" "jsx_namespace_name" "pattern" "decorator" "jsx_opening_element"))
    ("if_statement" ("statement"))
    ("import" ("primary_expression"))
    ("import_clause" ("import_statement"))
    ("import_specifier" ("named_imports"))
    ("import_statement" ("statement"))
    ("jsx_attribute" ("jsx_self_closing_element" "jsx_opening_element"))
    ("jsx_closing_element" ("jsx_element"))
    ("jsx_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_expression" ("jsx_self_closing_element" "jsx_attribute" "jsx_element" "jsx_opening_element"))
    ("jsx_namespace_name" ("jsx_self_closing_element" "jsx_attribute" "jsx_closing_element" "jsx_opening_element"))
    ("jsx_opening_element" ("jsx_element"))
    ("jsx_self_closing_element" ("jsx_attribute" "jsx_element" "expression"))
    ("jsx_text" ("jsx_element"))
    ("labeled_statement" ("statement"))
    ("lexical_declaration" ("for_statement" "declaration"))
    ("member_expression" ("member_expression" "primary_expression" "pattern" "jsx_self_closing_element" "jsx_closing_element" "decorator" "rest_pattern" "augmented_assignment_expression" "jsx_opening_element" "for_in_statement" "assignment_expression"))
    ("meta_property" ("primary_expression"))
    ("method_definition" ("object" "class_body"))
    ("named_imports" ("import_clause"))
    ("namespace_export" ("export_statement"))
    ("namespace_import" ("import_clause"))
    ("new_expression" ("new_expression" "expression"))
    ("null" ("primary_expression"))
    ("number" ("primary_expression" "method_definition" "pair" "pair_pattern" "field_definition"))
    ("object" ("primary_expression"))
    ("object_assignment_pattern" ("object_pattern"))
    ("object_pattern" ("for_in_statement" "pattern" "assignment_expression" "rest_pattern" "object_assignment_pattern" "variable_declarator" "catch_clause"))
    ("optional_chain" ("member_expression" "call_expression" "subscript_expression"))
    ("pair" ("object"))
    ("pair_pattern" ("object_pattern"))
    ("parenthesized_expression" ("primary_expression" "while_statement" "switch_statement" "with_statement" "if_statement" "do_statement" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("pattern" ("formal_parameters" "assignment_pattern" "pair_pattern" "array_pattern"))
    ("primary_expression" ("new_expression" "expression"))
    ("private_property_identifier" ("member_expression" "method_definition" "pair" "binary_expression" "pair_pattern" "field_definition"))
    ("property_identifier" ("member_expression" "jsx_attribute" "method_definition" "pair" "pair_pattern" "field_definition"))
    ("regex" ("primary_expression"))
    ("regex_flags" ("regex"))
    ("regex_pattern" ("regex"))
    ("rest_pattern" ("pattern" "object_pattern"))
    ("return_statement" ("statement"))
    ("sequence_expression" ("jsx_expression" "sequence_expression" "parenthesized_expression" "for_statement" "throw_statement" "expression_statement" "return_statement" "switch_case" "for_in_statement" "template_substitution" "subscript_expression"))
    ("shorthand_property_identifier" ("object"))
    ("shorthand_property_identifier_pattern" ("object_assignment_pattern" "object_pattern"))
    ("spread_element" ("array" "arguments" "jsx_expression" "object"))
    ("statement" ("switch_default" "while_statement" "for_statement" "statement_block" "with_statement" "if_statement" "do_statement" "else_clause" "labeled_statement" "program" "switch_case" "for_in_statement"))
    ("statement_block" ("finally_clause" "method_definition" "statement" "arrow_function" "generator_function" "generator_function_declaration" "try_statement" "function_declaration" "class_static_block" "function" "catch_clause"))
    ("statement_identifier" ("labeled_statement" "continue_statement" "break_statement"))
    ("string" ("primary_expression" "jsx_attribute" "export_specifier" "method_definition" "export_statement" "import_statement" "pair" "namespace_export" "pair_pattern" "import_specifier" "field_definition"))
    ("string_fragment" ("string"))
    ("subscript_expression" ("primary_expression" "pattern" "rest_pattern" "augmented_assignment_expression" "for_in_statement" "assignment_expression"))
    ("super" ("primary_expression"))
    ("switch_body" ("switch_statement"))
    ("switch_case" ("switch_body"))
    ("switch_default" ("switch_body"))
    ("switch_statement" ("statement"))
    ("template_string" ("primary_expression" "call_expression"))
    ("template_substitution" ("template_string"))
    ("ternary_expression" ("expression"))
    ("this" ("primary_expression"))
    ("throw_statement" ("statement"))
    ("true" ("primary_expression"))
    ("try_statement" ("statement"))
    ("unary_expression" ("expression"))
    ("undefined" ("primary_expression" "pattern" "rest_pattern" "for_in_statement" "assignment_expression"))
    ("update_expression" ("expression"))
    ("variable_declaration" ("for_statement" "declaration"))
    ("variable_declarator" ("variable_declaration" "lexical_declaration"))
    ("while_statement" ("statement"))
    ("with_statement" ("statement"))
    ("yield_expression" ("expression"))
    )
  )
;; END Inverse production rules for jsx
;; START All node types in jsx
(defconst combobulate-rules-jsx-types
  '("arguments" "array" "array_pattern" "arrow_function" "assignment_expression" "assignment_pattern" "augmented_assignment_expression" "await_expression" "binary_expression" "break_statement" "call_expression" "catch_clause" "class" "class_body" "class_declaration" "class_heritage" "class_static_block" "comment" "computed_property_name" "continue_statement" "debugger_statement" "declaration" "decorator" "do_statement" "else_clause" "empty_statement" "escape_sequence" "export_clause" "export_specifier" "export_statement" "expression" "expression_statement" "false" "field_definition" "finally_clause" "for_in_statement" "for_statement" "formal_parameters" "function" "function_declaration" "generator_function" "generator_function_declaration" "glimmer_closing_tag" "glimmer_opening_tag" "glimmer_template" "hash_bang_line" "identifier" "if_statement" "import" "import_clause" "import_specifier" "import_statement" "jsx_attribute" "jsx_closing_element" "jsx_element" "jsx_expression" "jsx_namespace_name" "jsx_opening_element" "jsx_self_closing_element" "jsx_text" "labeled_statement" "lexical_declaration" "member_expression" "meta_property" "method_definition" "named_imports" "namespace_export" "namespace_import" "new_expression" "null" "number" "object" "object_assignment_pattern" "object_pattern" "optional_chain" "pair" "pair_pattern" "parenthesized_expression" "pattern" "primary_expression" "private_property_identifier" "program" "property_identifier" "regex" "regex_flags" "regex_pattern" "rest_pattern" "return_statement" "sequence_expression" "shorthand_property_identifier" "shorthand_property_identifier_pattern" "spread_element" "statement" "statement_block" "statement_identifier" "string" "string_fragment" "subscript_expression" "super" "switch_body" "switch_case" "switch_default" "switch_statement" "template_string" "template_substitution" "ternary_expression" "this" "throw_statement" "true" "try_statement" "unary_expression" "undefined" "update_expression" "variable_declaration" "variable_declarator" "while_statement" "with_statement" "yield_expression")
  )
;; END All node types in jsx

;; START Production rules for go
(defconst combobulate-rules-go
  '(("_expression" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("_simple_statement" (:*unnamed* ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement")))
    ("_simple_type" (:*unnamed* ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("_statement" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement")))
    ("_type" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("argument_list" (:*unnamed* ("slice_type" "function_type" "parenthesized_expression" "type_assertion_expression" "map_type" "interpreted_string_literal" "binary_expression" "generic_type" "qualified_type" "array_type" "selector_expression" "type_identifier" "variadic_argument" "interface_type" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "union_type" "parenthesized_type" "identifier" "float_literal" "call_expression" "imaginary_literal" "index_expression" "negated_type" "nil" "type_conversion_expression" "false" "raw_string_literal" "iota" "struct_type" "rune_literal" "pointer_type" "channel_type" "unary_expression")))
    ("array_type" (:element ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :length ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("assignment_statement" (:left ("expression_list") :operator nil :right ("expression_list")))
    ("binary_expression" (:left ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :operator nil :right ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("block" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement")))
    ("break_statement" (:*unnamed* ("label_name")))
    ("call_expression" (:arguments ("argument_list") :function ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :type_arguments ("type_arguments")))
    ("channel_type" (:value ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("communication_case" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement") :communication ("receive_statement" "send_statement")))
    ("composite_literal" (:body ("literal_value") :type ("type_identifier" "slice_type" "struct_type" "map_type" "generic_type" "qualified_type" "implicit_length_array_type" "array_type")))
    ("const_declaration" (:*unnamed* ("const_spec")))
    ("const_spec" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :value ("expression_list")))
    ("continue_statement" (:*unnamed* ("label_name")))
    ("dec_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("default_case" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement")))
    ("defer_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("expression_case" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement") :value ("expression_list")))
    ("expression_list" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("expression_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("expression_switch_statement" (:*unnamed* ("expression_case" "default_case") :initializer ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement") :value ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("field_declaration" (:name ("field_identifier") :tag ("interpreted_string_literal" "raw_string_literal") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("field_declaration_list" (:*unnamed* ("field_declaration")))
    ("for_clause" (:condition ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :initializer ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement") :update ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement")))
    ("for_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "for_clause" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "range_clause" "unary_expression") :body ("block")))
    ("func_literal" (:body ("block") :parameters ("parameter_list") :result ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "parameter_list" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("function_declaration" (:body ("block") :name ("identifier") :parameters ("parameter_list") :result ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "parameter_list" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :type_parameters ("type_parameter_list")))
    ("function_type" (:parameters ("parameter_list") :result ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "parameter_list" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("generic_type" (:type ("type_identifier" "negated_type" "qualified_type" "union_type") :type_arguments ("type_arguments")))
    ("go_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("goto_statement" (:*unnamed* ("label_name")))
    ("if_statement" (:alternative ("if_statement" "block") :condition ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :consequence ("block") :initializer ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement")))
    ("implicit_length_array_type" (:element ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("import_declaration" (:*unnamed* ("import_spec_list" "import_spec")))
    ("import_spec" (:name ("package_identifier" "blank_identifier" "dot") :path ("interpreted_string_literal" "raw_string_literal")))
    ("import_spec_list" (:*unnamed* ("import_spec")))
    ("inc_statement" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("index_expression" (:index ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("interface_type" (:*unnamed* ("constraint_elem" "method_spec" "struct_elem")))
    ("interpreted_string_literal" (:*unnamed* ("escape_sequence")))
    ("keyed_element" (:*unnamed* ("literal_element")))
    ("labeled_statement" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement") :label ("label_name")))
    ("literal_element" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "literal_value" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("literal_value" (:*unnamed* ("literal_element" "keyed_element")))
    ("map_type" (:key ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :value ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("method_declaration" (:body ("block") :name ("field_identifier") :parameters ("parameter_list") :receiver ("parameter_list") :result ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "parameter_list" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("method_spec" (:name ("field_identifier") :parameters ("parameter_list") :result ("type_identifier" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "parameter_list" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("negated_type" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("package_clause" (:*unnamed* ("package_identifier")))
    ("parameter_declaration" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("parameter_list" (:*unnamed* ("variadic_parameter_declaration" "parameter_declaration")))
    ("parenthesized_expression" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("parenthesized_type" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("pointer_type" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("qualified_type" (:name ("type_identifier") :package ("package_identifier")))
    ("range_clause" (:left ("expression_list") :right ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("receive_statement" (:left ("expression_list") :right ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("return_statement" (:*unnamed* ("expression_list")))
    ("select_statement" (:*unnamed* ("communication_case" "default_case")))
    ("selector_expression" (:field ("field_identifier") :operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("send_statement" (:channel ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :value ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("short_var_declaration" (:left ("expression_list") :right ("expression_list")))
    ("slice_expression" (:capacity ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :end ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :start ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("slice_type" (:element ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("source_file" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "package_clause" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "method_declaration" "import_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "function_declaration" "goto_statement" "block" "labeled_statement")))
    ("struct_elem" (:*unnamed* ("struct_term")))
    ("struct_term" (:*unnamed* ("struct_type")))
    ("struct_type" (:*unnamed* ("field_declaration_list")))
    ("type_alias" (:name ("type_identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("type_arguments" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("type_assertion_expression" (:operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("type_case" (:*unnamed* ("continue_statement" "defer_statement" "type_switch_statement" "send_statement" "for_statement" "if_statement" "dec_statement" "inc_statement" "return_statement" "type_declaration" "short_var_declaration" "assignment_statement" "select_statement" "fallthrough_statement" "go_statement" "empty_statement" "const_declaration" "var_declaration" "expression_switch_statement" "expression_statement" "break_statement" "goto_statement" "block" "labeled_statement") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("type_conversion_expression" (:operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("type_declaration" (:*unnamed* ("type_spec" "type_alias")))
    ("type_parameter_list" (:*unnamed* ("parameter_declaration")))
    ("type_spec" (:name ("type_identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :type_parameters ("type_parameter_list")))
    ("type_switch_statement" (:*unnamed* ("type_case" "default_case") :alias ("expression_list") :initializer ("short_var_declaration" "dec_statement" "inc_statement" "send_statement" "expression_statement" "assignment_statement") :value ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("unary_expression" (:operand ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression") :operator nil))
    ("union_type" (:*unnamed* ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("var_declaration" (:*unnamed* ("var_spec")))
    ("var_spec" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type") :value ("expression_list")))
    ("variadic_argument" (:*unnamed* ("identifier" "float_literal" "parenthesized_expression" "type_assertion_expression" "interpreted_string_literal" "binary_expression" "call_expression" "imaginary_literal" "index_expression" "nil" "selector_expression" "type_conversion_expression" "false" "raw_string_literal" "iota" "true" "func_literal" "int_literal" "composite_literal" "slice_expression" "rune_literal" "unary_expression")))
    ("variadic_parameter_declaration" (:name ("identifier") :type ("type_identifier" "parenthesized_type" "slice_type" "function_type" "interface_type" "struct_type" "map_type" "generic_type" "pointer_type" "channel_type" "negated_type" "qualified_type" "union_type" "array_type")))
    ("blank_identifier" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("field_identifier" (:*unnamed* nil))
    ("float_literal" (:*unnamed* nil))
    ("identifier" (:*unnamed* nil))
    ("imaginary_literal" (:*unnamed* nil))
    ("int_literal" (:*unnamed* nil))
    ("iota" (:*unnamed* nil))
    ("label_name" (:*unnamed* nil))
    ("nil" (:*unnamed* nil))
    ("package_identifier" (:*unnamed* nil))
    ("raw_string_literal" (:*unnamed* nil))
    ("rune_literal" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("type_identifier" (:*unnamed* nil))
    ))
;; END Production rules for go
;; START Inverse production rules for go
(defconst combobulate-rules-go-inverse
  '(("argument_list" ("call_expression"))
    ("array_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("assignment_statement" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("binary_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("blank_identifier" ("import_spec"))
    ("block" ("for_statement" "if_statement" "expression_case" "func_literal" "function_declaration" "communication_case" "_statement" "method_declaration" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("break_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("call_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("channel_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("communication_case" ("select_statement"))
    ("composite_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("const_declaration" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("const_spec" ("const_declaration"))
    ("constraint_elem" ("interface_type"))
    ("continue_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("dec_statement" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("default_case" ("select_statement" "expression_switch_statement" "type_switch_statement"))
    ("defer_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("dot" ("import_spec"))
    ("empty_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("escape_sequence" ("interpreted_string_literal"))
    ("expression_case" ("expression_switch_statement"))
    ("expression_list" ("type_switch_statement" "var_spec" "const_spec" "expression_case" "receive_statement" "return_statement" "range_clause" "short_var_declaration" "assignment_statement"))
    ("expression_statement" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("expression_switch_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("fallthrough_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("false" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("field_declaration" ("field_declaration_list"))
    ("field_declaration_list" ("struct_type"))
    ("field_identifier" ("selector_expression" "field_declaration" "method_declaration" "method_spec"))
    ("float_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("for_clause" ("for_statement"))
    ("for_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("func_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("function_declaration" ("source_file"))
    ("function_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("generic_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("go_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("goto_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("identifier" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "variadic_parameter_declaration" "go_statement" "for_clause" "expression_list" "function_declaration" "receive_statement" "slice_expression" "range_clause" "var_spec" "_expression" "const_spec" "for_statement" "call_expression" "index_expression" "parameter_declaration" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("if_statement" ("if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("imaginary_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("implicit_length_array_type" ("composite_literal"))
    ("import_declaration" ("source_file"))
    ("import_spec" ("import_declaration" "import_spec_list"))
    ("import_spec_list" ("import_declaration"))
    ("inc_statement" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("index_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("int_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("interface_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("interpreted_string_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "field_declaration" "expression_list" "receive_statement" "slice_expression" "import_spec" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("iota" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("keyed_element" ("literal_value"))
    ("label_name" ("labeled_statement" "continue_statement" "break_statement" "goto_statement"))
    ("labeled_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("literal_element" ("literal_value" "keyed_element"))
    ("literal_value" ("composite_literal" "literal_element"))
    ("map_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("method_declaration" ("source_file"))
    ("method_spec" ("interface_type"))
    ("negated_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "generic_type" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("nil" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("package_clause" ("source_file"))
    ("package_identifier" ("qualified_type" "package_clause" "import_spec"))
    ("parameter_declaration" ("parameter_list" "type_parameter_list"))
    ("parameter_list" ("function_type" "func_literal" "function_declaration" "method_spec" "method_declaration"))
    ("parenthesized_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("parenthesized_type" ("slice_type" "type_assertion_expression" "type_alias" "map_type" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "type_arguments" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "pointer_type" "channel_type" "type_case"))
    ("pointer_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("qualified_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "generic_type" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("range_clause" ("for_statement"))
    ("raw_string_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "field_declaration" "expression_list" "receive_statement" "slice_expression" "import_spec" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("receive_statement" ("communication_case"))
    ("return_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("rune_literal" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("select_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("selector_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("send_statement" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("short_var_declaration" ("type_switch_statement" "_simple_statement" "for_clause" "expression_switch_statement" "if_statement" "expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("slice_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("slice_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("struct_elem" ("interface_type"))
    ("struct_term" ("struct_elem"))
    ("struct_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "struct_term" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("true" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("type_alias" ("type_declaration"))
    ("type_arguments" ("generic_type" "call_expression"))
    ("type_assertion_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("type_case" ("type_switch_statement"))
    ("type_conversion_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("type_declaration" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("type_identifier" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "generic_type" "method_declaration" "qualified_type" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "composite_literal" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("type_parameter_list" ("type_spec" "function_declaration"))
    ("type_spec" ("type_declaration"))
    ("type_switch_statement" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("unary_expression" ("defer_statement" "type_switch_statement" "send_statement" "parenthesized_expression" "type_assertion_expression" "if_statement" "dec_statement" "binary_expression" "inc_statement" "array_type" "selector_expression" "variadic_argument" "go_statement" "for_clause" "expression_list" "receive_statement" "slice_expression" "range_clause" "_expression" "for_statement" "call_expression" "index_expression" "argument_list" "type_conversion_expression" "expression_switch_statement" "expression_statement" "literal_element" "unary_expression"))
    ("union_type" ("slice_type" "function_type" "type_assertion_expression" "_simple_type" "map_type" "type_alias" "generic_type" "method_declaration" "implicit_length_array_type" "array_type" "variadic_parameter_declaration" "field_declaration" "func_literal" "function_declaration" "type_case" "var_spec" "union_type" "parenthesized_type" "type_spec" "const_spec" "_type" "negated_type" "parameter_declaration" "argument_list" "type_conversion_expression" "method_spec" "pointer_type" "channel_type" "type_arguments"))
    ("var_declaration" ("expression_case" "communication_case" "_statement" "type_case" "block" "labeled_statement" "source_file" "default_case"))
    ("var_spec" ("var_declaration"))
    ("variadic_argument" ("argument_list"))
    ("variadic_parameter_declaration" ("parameter_list"))
    )
  )
;; END Inverse production rules for go
;; START All node types in go
(defconst combobulate-rules-go-types
  '("_expression" "_simple_statement" "_simple_type" "_statement" "_type" "argument_list" "array_type" "assignment_statement" "binary_expression" "blank_identifier" "block" "break_statement" "call_expression" "channel_type" "comment" "communication_case" "composite_literal" "const_declaration" "const_spec" "constraint_elem" "continue_statement" "dec_statement" "default_case" "defer_statement" "dot" "empty_statement" "escape_sequence" "expression_case" "expression_list" "expression_statement" "expression_switch_statement" "fallthrough_statement" "false" "field_declaration" "field_declaration_list" "field_identifier" "float_literal" "for_clause" "for_statement" "func_literal" "function_declaration" "function_type" "generic_type" "go_statement" "goto_statement" "identifier" "if_statement" "imaginary_literal" "implicit_length_array_type" "import_declaration" "import_spec" "import_spec_list" "inc_statement" "index_expression" "int_literal" "interface_type" "interpreted_string_literal" "iota" "keyed_element" "label_name" "labeled_statement" "literal_element" "literal_value" "map_type" "method_declaration" "method_spec" "negated_type" "nil" "package_clause" "package_identifier" "parameter_declaration" "parameter_list" "parenthesized_expression" "parenthesized_type" "pointer_type" "qualified_type" "range_clause" "raw_string_literal" "receive_statement" "return_statement" "rune_literal" "select_statement" "selector_expression" "send_statement" "short_var_declaration" "slice_expression" "slice_type" "source_file" "struct_elem" "struct_term" "struct_type" "true" "type_alias" "type_arguments" "type_assertion_expression" "type_case" "type_conversion_expression" "type_declaration" "type_identifier" "type_parameter_list" "type_spec" "type_switch_statement" "unary_expression" "union_type" "var_declaration" "var_spec" "variadic_argument" "variadic_parameter_declaration")
  )
;; END All node types in go

;; START Production rules for python
(defconst combobulate-rules-python
  '(("_compound_statement" (:*unnamed* ("function_definition" "while_statement" "decorated_definition" "for_statement" "with_statement" "try_statement" "match_statement" "if_statement" "class_definition")))
    ("_simple_statement" (:*unnamed* ("raise_statement" "continue_statement" "assert_statement" "type_alias_statement" "delete_statement" "import_statement" "return_statement" "pass_statement" "print_statement" "expression_statement" "future_import_statement" "break_statement" "nonlocal_statement" "global_statement" "exec_statement" "import_from_statement")))
    ("expression" (:*unnamed* ("primary_expression" "not_operator" "as_pattern" "comparison_operator" "lambda" "named_expression" "boolean_operator" "conditional_expression")))
    ("parameter" (:*unnamed* ("list_splat_pattern" "identifier" "typed_parameter" "tuple_pattern" "keyword_separator" "positional_separator" "typed_default_parameter" "dictionary_splat_pattern" "default_parameter")))
    ("pattern" (:*unnamed* ("list_splat_pattern" "identifier" "tuple_pattern" "subscript" "attribute" "list_pattern")))
    ("primary_expression" (:*unnamed* ("dictionary" "identifier" "string" "parenthesized_expression" "tuple" "attribute" "list" "await" "dictionary_comprehension" "float" "none" "unary_operator" "ellipsis" "list_comprehension" "false" "set_comprehension" "generator_expression" "subscript" "true" "list_splat" "binary_operator" "call" "concatenated_string" "integer" "set")))
    ("aliased_import" (:alias ("identifier") :name ("dotted_name")))
    ("argument_list" (:*unnamed* ("list_splat" "expression" "keyword_argument" "parenthesized_expression" "dictionary_splat")))
    ("as_pattern" (:*unnamed* ("case_pattern" "identifier" "expression") :alias ("as_pattern_target")))
    ("assert_statement" (:*unnamed* ("expression")))
    ("assignment" (:left ("pattern_list" "pattern") :right ("augmented_assignment" "yield" "expression" "pattern_list" "expression_list" "assignment") :type ("type")))
    ("attribute" (:attribute ("identifier") :object ("primary_expression")))
    ("augmented_assignment" (:left ("pattern_list" "pattern") :operator nil :right ("augmented_assignment" "yield" "expression" "pattern_list" "expression_list" "assignment")))
    ("await" (:*unnamed* ("primary_expression")))
    ("binary_operator" (:left ("primary_expression") :operator nil :right ("primary_expression")))
    ("block" (:*unnamed* ("raise_statement" "continue_statement" "function_definition" "assert_statement" "type_alias_statement" "for_statement" "with_statement" "delete_statement" "if_statement" "import_statement" "return_statement" "class_definition" "pass_statement" "print_statement" "while_statement" "decorated_definition" "expression_statement" "try_statement" "match_statement" "future_import_statement" "break_statement" "nonlocal_statement" "global_statement" "exec_statement" "import_from_statement") :alternative ("case_clause")))
    ("boolean_operator" (:left ("expression") :operator nil :right ("expression")))
    ("call" (:arguments ("generator_expression" "argument_list") :function ("primary_expression")))
    ("case_clause" (:*unnamed* ("case_pattern") :consequence ("block") :guard ("if_clause")))
    ("case_pattern" (:*unnamed* ("string" "dotted_name" "float" "none" "union_pattern" "false" "tuple_pattern" "as_pattern" "class_pattern" "keyword_pattern" "list_pattern" "complex_pattern" "true" "splat_pattern" "concatenated_string" "dict_pattern" "integer")))
    ("chevron" (:*unnamed* ("expression")))
    ("class_definition" (:body ("block") :name ("identifier") :superclasses ("argument_list") :type_parameters ("type_parameter")))
    ("class_pattern" (:*unnamed* ("case_pattern" "dotted_name")))
    ("comparison_operator" (:*unnamed* ("primary_expression") :operators nil))
    ("complex_pattern" (:*unnamed* ("integer" "float")))
    ("concatenated_string" (:*unnamed* ("string")))
    ("conditional_expression" (:*unnamed* ("expression")))
    ("constrained_type" (:*unnamed* ("type")))
    ("decorated_definition" (:*unnamed* ("decorator") :definition ("function_definition" "class_definition")))
    ("decorator" (:*unnamed* ("expression")))
    ("default_parameter" (:name ("identifier" "tuple_pattern") :value ("expression")))
    ("delete_statement" (:*unnamed* ("expression_list" "expression")))
    ("dict_pattern" (:*unnamed* ("splat_pattern") :key ("false" "string" "tuple_pattern" "class_pattern" "list_pattern" "complex_pattern" "dotted_name" "splat_pattern" "float" "true" "none" "union_pattern" "concatenated_string" "dict_pattern" "integer") :value ("case_pattern")))
    ("dictionary" (:*unnamed* ("pair" "dictionary_splat")))
    ("dictionary_comprehension" (:*unnamed* ("for_in_clause" "if_clause") :body ("pair")))
    ("dictionary_splat" (:*unnamed* ("expression")))
    ("dictionary_splat_pattern" (:*unnamed* ("subscript" "attribute" "identifier")))
    ("dotted_name" (:*unnamed* ("identifier")))
    ("elif_clause" (:condition ("expression") :consequence ("block")))
    ("else_clause" (:body ("block")))
    ("except_clause" (:*unnamed* ("expression" "block")))
    ("except_group_clause" (:*unnamed* ("expression" "block")))
    ("exec_statement" (:*unnamed* ("expression") :code ("string" "identifier")))
    ("expression_list" (:*unnamed* ("expression")))
    ("expression_statement" (:*unnamed* ("augmented_assignment" "yield" "expression" "assignment")))
    ("finally_clause" (:*unnamed* ("block")))
    ("for_in_clause" (:left ("pattern_list" "pattern") :right ("expression")))
    ("for_statement" (:alternative ("else_clause") :body ("block") :left ("pattern_list" "pattern") :right ("expression_list" "expression")))
    ("format_expression" (:expression ("pattern_list" "yield" "expression_list" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion")))
    ("format_specifier" (:*unnamed* ("format_expression")))
    ("function_definition" (:body ("block") :name ("identifier") :parameters ("parameters") :return_type ("type") :type_parameters ("type_parameter")))
    ("future_import_statement" (:name ("aliased_import" "dotted_name")))
    ("generator_expression" (:*unnamed* ("for_in_clause" "if_clause") :body ("expression")))
    ("generic_type" (:*unnamed* ("identifier" "type_parameter")))
    ("global_statement" (:*unnamed* ("identifier")))
    ("if_clause" (:*unnamed* ("expression")))
    ("if_statement" (:alternative ("else_clause" "elif_clause") :condition ("expression") :consequence ("block")))
    ("import_from_statement" (:*unnamed* ("wildcard_import") :module_name ("relative_import" "dotted_name") :name ("aliased_import" "dotted_name")))
    ("import_statement" (:name ("aliased_import" "dotted_name")))
    ("interpolation" (:expression ("pattern_list" "yield" "expression_list" "expression") :format_specifier ("format_specifier") :type_conversion ("type_conversion")))
    ("keyword_argument" (:name ("identifier") :value ("expression")))
    ("keyword_pattern" (:*unnamed* ("identifier" "string" "dotted_name" "float" "none" "union_pattern" "false" "tuple_pattern" "class_pattern" "list_pattern" "complex_pattern" "true" "splat_pattern" "concatenated_string" "dict_pattern" "integer")))
    ("lambda" (:body ("expression") :parameters ("lambda_parameters")))
    ("lambda_parameters" (:*unnamed* ("parameter")))
    ("list" (:*unnamed* ("list_splat" "yield" "expression" "parenthesized_list_splat"))) 
    ("list_comprehension" (:*unnamed* ("for_in_clause" "if_clause") :body ("expression")))
    ("list_pattern" (:*unnamed* ("case_pattern" "pattern")))
    ("list_splat" (:*unnamed* ("subscript" "attribute" "expression" "identifier")))
    ("list_splat_pattern" (:*unnamed* ("subscript" "attribute" "identifier")))
    ("match_statement" (:body ("block") :subject ("expression")))
    ("member_type" (:*unnamed* ("type" "identifier")))
    ("module" (:*unnamed* ("raise_statement" "continue_statement" "function_definition" "assert_statement" "type_alias_statement" "for_statement" "with_statement" "delete_statement" "if_statement" "import_statement" "return_statement" "class_definition" "pass_statement" "print_statement" "while_statement" "decorated_definition" "expression_statement" "try_statement" "match_statement" "future_import_statement" "break_statement" "nonlocal_statement" "global_statement" "exec_statement" "import_from_statement")))
    ("named_expression" (:name ("identifier") :value ("expression")))
    ("nonlocal_statement" (:*unnamed* ("identifier")))
    ("not_operator" (:argument ("expression")))
    ("pair" (:key ("expression") :value ("expression")))
    ("parameters" (:*unnamed* ("parameter")))
    ("parenthesized_expression" (:*unnamed* ("parenthesized_expression" "list_splat" "yield" "expression")))
    ("parenthesized_list_splat" (:*unnamed* ("parenthesized_expression" "list_splat")))
    ("pattern_list" (:*unnamed* ("pattern")))
    ("print_statement" (:*unnamed* ("chevron") :argument ("expression")))
    ("raise_statement" (:*unnamed* ("expression_list" "expression") :cause ("expression")))
    ("relative_import" (:*unnamed* ("import_prefix" "dotted_name")))
    ("return_statement" (:*unnamed* ("expression_list" "expression")))
    ("set" (:*unnamed* ("list_splat" "yield" "expression" "parenthesized_list_splat")))
    ("set_comprehension" (:*unnamed* ("for_in_clause" "if_clause") :body ("expression")))
    ("slice" (:*unnamed* ("expression")))
    ("splat_pattern" (:*unnamed* ("identifier")))
    ("splat_type" (:*unnamed* ("identifier")))
    ("string" (:*unnamed* ("string_content" "string_start" "string_end" "interpolation")))
    ("string_content" (:*unnamed* ("escape_interpolation" "escape_sequence")))
    ("subscript" (:subscript ("slice" "expression") :value ("primary_expression")))
    ("try_statement" (:*unnamed* ("else_clause" "except_group_clause" "except_clause" "finally_clause") :body ("block")))
    ("tuple" (:*unnamed* ("list_splat" "yield" "expression" "parenthesized_list_splat")))
    ("tuple_pattern" (:*unnamed* ("case_pattern" "pattern")))
    ("type" (:*unnamed* ("constrained_type" "generic_type" "expression" "member_type" "splat_type" "union_type")))
    ("type_alias_statement" (:*unnamed* ("type")))
    ("type_parameter" (:*unnamed* ("type")))
    ("typed_default_parameter" (:name ("identifier") :type ("type") :value ("expression")))
    ("typed_parameter" (:*unnamed* ("list_splat_pattern" "identifier" "dictionary_splat_pattern") :type ("type")))
    ("unary_operator" (:argument ("primary_expression") :operator nil))
    ("union_pattern" (:*unnamed* ("false" "string" "tuple_pattern" "class_pattern" "list_pattern" "complex_pattern" "dotted_name" "splat_pattern" "float" "true" "none" "union_pattern" "concatenated_string" "dict_pattern" "integer")))
    ("union_type" (:*unnamed* ("type")))
    ("while_statement" (:alternative ("else_clause") :body ("block") :condition ("expression")))
    ("with_clause" (:*unnamed* ("with_item")))
    ("with_item" (:value ("expression")))
    ("with_statement" (:*unnamed* ("with_clause") :body ("block")))
    ("yield" (:*unnamed* ("expression_list" "expression")))
    ("comment" (:*unnamed* nil))
    ("ellipsis" (:*unnamed* nil))
    ("escape_interpolation" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("float" (:*unnamed* nil))
    ("identifier" (:*unnamed* nil))
    ("integer" (:*unnamed* nil))
    ("line_continuation" (:*unnamed* nil))
    ("none" (:*unnamed* nil))
    ("string_end" (:*unnamed* nil))
    ("string_start" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("type_conversion" (:*unnamed* nil))
    ))
;; END Production rules for python
;; START Inverse production rules for python
(defconst combobulate-rules-python-inverse
  '(("aliased_import" ("future_import_statement" "import_statement" "import_from_statement"))
    ("argument_list" ("call" "class_definition"))
    ("as_pattern" ("case_pattern" "expression"))
    ("as_pattern_target" ("as_pattern"))
    ("assert_statement" ("module" "_simple_statement" "block"))
    ("assignment" ("augmented_assignment" "expression_statement" "assignment"))
    ("attribute" ("primary_expression" "list_splat_pattern" "pattern" "list_splat" "dictionary_splat_pattern"))
    ("augmented_assignment" ("augmented_assignment" "expression_statement" "assignment"))
    ("await" ("primary_expression"))
    ("binary_operator" ("primary_expression"))
    ("block" ("function_definition" "while_statement" "finally_clause" "for_statement" "with_statement" "try_statement" "match_statement" "if_statement" "else_clause" "except_group_clause" "class_definition" "except_clause" "case_clause" "elif_clause"))
    ("boolean_operator" ("expression"))
    ("break_statement" ("module" "_simple_statement" "block"))
    ("call" ("primary_expression"))
    ("case_clause" ("block"))
    ("case_pattern" ("tuple_pattern" "as_pattern" "class_pattern" "list_pattern" "dict_pattern" "case_clause"))
    ("chevron" ("print_statement"))
    ("class_definition" ("_compound_statement" "module" "decorated_definition" "block"))
    ("class_pattern" ("case_pattern" "union_pattern" "dict_pattern" "keyword_pattern"))
    ("comparison_operator" ("expression"))
    ("complex_pattern" ("case_pattern" "union_pattern" "dict_pattern" "keyword_pattern"))
    ("concatenated_string" ("case_pattern" "primary_expression" "keyword_pattern" "union_pattern" "dict_pattern"))
    ("conditional_expression" ("expression"))
    ("constrained_type" ("type"))
    ("continue_statement" ("module" "_simple_statement" "block"))
    ("decorated_definition" ("_compound_statement" "module" "block"))
    ("decorator" ("decorated_definition"))
    ("default_parameter" ("parameter"))
    ("delete_statement" ("module" "_simple_statement" "block"))
    ("dict_pattern" ("case_pattern" "union_pattern" "dict_pattern" "keyword_pattern"))
    ("dictionary" ("primary_expression"))
    ("dictionary_comprehension" ("primary_expression"))
    ("dictionary_splat" ("dictionary" "argument_list"))
    ("dictionary_splat_pattern" ("parameter" "typed_parameter"))
    ("dotted_name" ("aliased_import" "case_pattern" "keyword_pattern" "class_pattern" "future_import_statement" "import_statement" "relative_import" "union_pattern" "dict_pattern" "import_from_statement"))
    ("elif_clause" ("if_statement"))
    ("ellipsis" ("primary_expression"))
    ("else_clause" ("for_statement" "while_statement" "try_statement" "if_statement"))
    ("escape_interpolation" ("string_content"))
    ("escape_sequence" ("string_content"))
    ("except_clause" ("try_statement"))
    ("except_group_clause" ("try_statement"))
    ("exec_statement" ("module" "_simple_statement" "block"))
    ("expression" ("augmented_assignment" "chevron" "parenthesized_expression" "tuple" "type" "delete_statement" "if_statement" "except_group_clause" "return_statement" "boolean_operator" "conditional_expression" "dictionary_splat" "print_statement" "interpolation" "list_comprehension" "set_comprehension" "expression_list" "match_statement" "assignment" "pair" "lambda" "except_clause" "if_clause" "exec_statement" "raise_statement" "format_expression" "assert_statement" "not_operator" "typed_default_parameter" "for_statement" "list" "keyword_argument" "slice" "default_parameter" "with_item" "elif_clause" "argument_list" "yield" "while_statement" "generator_expression" "as_pattern" "for_in_clause" "subscript" "expression_statement" "decorator" "list_splat" "named_expression" "set"))
    ("expression_list" ("raise_statement" "format_expression" "augmented_assignment" "for_statement" "delete_statement" "assignment" "return_statement" "yield" "interpolation"))
    ("expression_statement" ("module" "_simple_statement" "block"))
    ("false" ("case_pattern" "primary_expression" "keyword_pattern" "union_pattern" "dict_pattern"))
    ("finally_clause" ("try_statement"))
    ("float" ("case_pattern" "primary_expression" "keyword_pattern" "complex_pattern" "union_pattern" "dict_pattern"))
    ("for_in_clause" ("generator_expression" "set_comprehension" "dictionary_comprehension" "list_comprehension"))
    ("for_statement" ("_compound_statement" "module" "block"))
    ("format_expression" ("format_specifier"))
    ("format_specifier" ("format_expression" "interpolation"))
    ("function_definition" ("_compound_statement" "module" "decorated_definition" "block"))
    ("future_import_statement" ("module" "_simple_statement" "block"))
    ("generator_expression" ("primary_expression" "call"))
    ("generic_type" ("type"))
    ("global_statement" ("module" "_simple_statement" "block"))
    ("identifier" ("attribute" "generic_type" "aliased_import" "splat_pattern" "dictionary_splat_pattern" "global_statement" "exec_statement" "list_splat_pattern" "function_definition" "typed_parameter" "typed_default_parameter" "dotted_name" "keyword_argument" "class_definition" "default_parameter" "primary_expression" "pattern" "as_pattern" "keyword_pattern" "parameter" "list_splat" "nonlocal_statement" "named_expression" "member_type" "splat_type"))
    ("if_clause" ("set_comprehension" "generator_expression" "dictionary_comprehension" "case_clause" "list_comprehension"))
    ("if_statement" ("_compound_statement" "module" "block"))
    ("import_from_statement" ("module" "_simple_statement" "block"))
    ("import_prefix" ("relative_import"))
    ("import_statement" ("module" "_simple_statement" "block"))
    ("integer" ("case_pattern" "primary_expression" "keyword_pattern" "complex_pattern" "union_pattern" "dict_pattern"))
    ("interpolation" ("string"))
    ("keyword_argument" ("argument_list"))
    ("keyword_pattern" ("case_pattern"))
    ("keyword_separator" ("parameter"))
    ("lambda" ("expression"))
    ("lambda_parameters" ("lambda"))
    ("list" ("primary_expression"))
    ("list_comprehension" ("primary_expression"))
    ("list_pattern" ("case_pattern" "pattern" "keyword_pattern" "union_pattern" "dict_pattern"))
    ("list_splat" ("primary_expression" "parenthesized_expression" "tuple" "list" "parenthesized_list_splat" "set" "argument_list"))
    ("list_splat_pattern" ("parameter" "typed_parameter" "pattern"))
    ("match_statement" ("_compound_statement" "module" "block"))
    ("member_type" ("type"))
    ("named_expression" ("expression"))
    ("none" ("case_pattern" "primary_expression" "keyword_pattern" "union_pattern" "dict_pattern"))
    ("nonlocal_statement" ("module" "_simple_statement" "block"))
    ("not_operator" ("expression"))
    ("pair" ("dictionary" "dictionary_comprehension"))
    ("parameter" ("parameters" "lambda_parameters"))
    ("parameters" ("function_definition"))
    ("parenthesized_expression" ("parenthesized_expression" "primary_expression" "argument_list" "parenthesized_list_splat"))
    ("parenthesized_list_splat" ("tuple" "list" "set"))
    ("pass_statement" ("module" "_simple_statement" "block"))
    ("pattern" ("augmented_assignment" "tuple_pattern" "for_in_clause" "for_statement" "list_pattern" "assignment" "pattern_list"))
    ("pattern_list" ("augmented_assignment" "format_expression" "for_in_clause" "for_statement" "assignment" "interpolation"))
    ("positional_separator" ("parameter"))
    ("primary_expression" ("expression" "subscript" "attribute" "await" "comparison_operator" "binary_operator" "call" "unary_operator"))
    ("print_statement" ("module" "_simple_statement" "block"))
    ("raise_statement" ("module" "_simple_statement" "block"))
    ("relative_import" ("import_from_statement"))
    ("return_statement" ("module" "_simple_statement" "block"))
    ("set" ("primary_expression"))
    ("set_comprehension" ("primary_expression"))
    ("slice" ("subscript"))
    ("splat_pattern" ("case_pattern" "union_pattern" "dict_pattern" "keyword_pattern"))
    ("splat_type" ("type"))
    ("string" ("case_pattern" "primary_expression" "keyword_pattern" "union_pattern" "dict_pattern" "concatenated_string" "exec_statement"))
    ("string_content" ("string"))
    ("string_end" ("string"))
    ("string_start" ("string"))
    ("subscript" ("primary_expression" "list_splat_pattern" "pattern" "list_splat" "dictionary_splat_pattern"))
    ("true" ("case_pattern" "primary_expression" "keyword_pattern" "union_pattern" "dict_pattern"))
    ("try_statement" ("_compound_statement" "module" "block"))
    ("tuple" ("primary_expression"))
    ("tuple_pattern" ("case_pattern" "pattern" "keyword_pattern" "parameter" "union_pattern" "dict_pattern" "default_parameter"))
    ("type" ("constrained_type" "function_definition" "typed_parameter" "type_alias_statement" "typed_default_parameter" "assignment" "member_type" "union_type" "type_parameter"))
    ("type_alias_statement" ("module" "_simple_statement" "block"))
    ("type_conversion" ("format_expression" "interpolation"))
    ("type_parameter" ("generic_type" "function_definition" "class_definition"))
    ("typed_default_parameter" ("parameter"))
    ("typed_parameter" ("parameter"))
    ("unary_operator" ("primary_expression"))
    ("union_pattern" ("case_pattern" "union_pattern" "dict_pattern" "keyword_pattern"))
    ("union_type" ("type"))
    ("while_statement" ("_compound_statement" "module" "block"))
    ("wildcard_import" ("import_from_statement"))
    ("with_clause" ("with_statement"))
    ("with_item" ("with_clause"))
    ("with_statement" ("_compound_statement" "module" "block"))
    ("yield" ("format_expression" "augmented_assignment" "parenthesized_expression" "tuple" "expression_statement" "list" "assignment" "set" "interpolation"))
    )
  )
;; END Inverse production rules for python
;; START All node types in python
(defconst combobulate-rules-python-types
  '("_compound_statement" "_simple_statement" "aliased_import" "argument_list" "as_pattern" "as_pattern_target" "assert_statement" "assignment" "attribute" "augmented_assignment" "await" "binary_operator" "block" "boolean_operator" "break_statement" "call" "case_clause" "case_pattern" "chevron" "class_definition" "class_pattern" "comment" "comparison_operator" "complex_pattern" "concatenated_string" "conditional_expression" "constrained_type" "continue_statement" "decorated_definition" "decorator" "default_parameter" "delete_statement" "dict_pattern" "dictionary" "dictionary_comprehension" "dictionary_splat" "dictionary_splat_pattern" "dotted_name" "elif_clause" "ellipsis" "else_clause" "escape_interpolation" "escape_sequence" "except_clause" "except_group_clause" "exec_statement" "expression" "expression_list" "expression_statement" "false" "finally_clause" "float" "for_in_clause" "for_statement" "format_expression" "format_specifier" "function_definition" "future_import_statement" "generator_expression" "generic_type" "global_statement" "identifier" "if_clause" "if_statement" "import_from_statement" "import_prefix" "import_statement" "integer" "interpolation" "keyword_argument" "keyword_pattern" "keyword_separator" "lambda" "lambda_parameters" "line_continuation" "list" "list_comprehension" "list_pattern" "list_splat" "list_splat_pattern" "match_statement" "member_type" "module" "named_expression" "none" "nonlocal_statement" "not_operator" "pair" "parameter" "parameters" "parenthesized_expression" "parenthesized_list_splat" "pass_statement" "pattern" "pattern_list" "positional_separator" "primary_expression" "print_statement" "raise_statement" "relative_import" "return_statement" "set" "set_comprehension" "slice" "splat_pattern" "splat_type" "string" "string_content" "string_end" "string_start" "subscript" "true" "try_statement" "tuple" "tuple_pattern" "type" "type_alias_statement" "type_conversion" "type_parameter" "typed_default_parameter" "typed_parameter" "unary_operator" "union_pattern" "union_type" "while_statement" "wildcard_import" "with_clause" "with_item" "with_statement" "yield")
  )
;; END All node types in python

;; START Production rules for c
(defconst combobulate-rules-c
  '(("_abstract_declarator" (:*unnamed* ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator")))
    ("_declarator" (:*unnamed* ("parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "array_declarator")))
    ("_expression" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("_field_declarator" (:*unnamed* ("parenthesized_declarator" "attributed_declarator" "function_declarator" "array_declarator" "pointer_declarator" "field_identifier")))
    ("_statement" (:*unnamed* ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement")))
    ("_type_declarator" (:*unnamed* ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "array_declarator" "pointer_declarator" "primitive_type")))
    ("_type_specifier" (:*unnamed* ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("abstract_array_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator") :size ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("abstract_function_declarator" (:declarator ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator") :parameters ("parameter_list")))
    ("abstract_parenthesized_declarator" (:*unnamed* ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator")))
    ("abstract_pointer_declarator" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator")))
    ("alignof_expression" (:type ("type_descriptor")))
    ("argument_list" (:*unnamed* ("offsetof_expression" "identifier" "preproc_defined" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "compound_statement" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("array_declarator" (:*unnamed* ("type_qualifier") :declarator ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "primitive_type" "field_identifier" "array_declarator") :size ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("assignment_expression" (:left ("identifier" "call_expression" "pointer_expression" "parenthesized_expression" "field_expression" "subscript_expression") :operator nil :right ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("attribute" (:*unnamed* ("argument_list") :name ("identifier") :prefix ("identifier")))
    ("attribute_declaration" (:*unnamed* ("attribute")))
    ("attribute_specifier" (:*unnamed* ("argument_list")))
    ("attributed_declarator" (:*unnamed* ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "primitive_type" "field_identifier" "array_declarator" "attribute_declaration")))
    ("attributed_statement" (:*unnamed* ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "attribute_declaration" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement")))
    ("binary_expression" (:left ("offsetof_expression" "identifier" "preproc_defined" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :operator nil :right ("offsetof_expression" "identifier" "preproc_defined" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("bitfield_clause" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("call_expression" (:arguments ("argument_list") :function ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("case_statement" (:*unnamed* ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "declaration" "return_statement" "compound_statement" "type_definition" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("cast_expression" (:type ("type_descriptor") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("char_literal" (:*unnamed* ("escape_sequence" "character")))
    ("comma_expression" (:left ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :right ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("compound_literal_expression" (:type ("type_descriptor") :value ("initializer_list")))
    ("compound_statement" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier")))
    ("concatenated_string" (:*unnamed* ("string_literal" "identifier")))
    ("conditional_expression" (:alternative ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :condition ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :consequence ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("declaration" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier" "storage_class_specifier" "attribute_declaration" "type_qualifier") :declarator ("parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "gnu_asm_expression" "array_declarator" "init_declarator") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("declaration_list" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier")))
    ("do_statement" (:body ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement") :condition ("parenthesized_expression")))
    ("else_clause" (:*unnamed* ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement")))
    ("enum_specifier" (:*unnamed* ("attribute_specifier") :body ("enumerator_list") :name ("type_identifier") :underlying_type ("primitive_type")))
    ("enumerator" (:name ("identifier") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("enumerator_list" (:*unnamed* ("enumerator")))
    ("expression_statement" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("field_declaration" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier" "storage_class_specifier" "bitfield_clause" "attribute_declaration" "type_qualifier") :declarator ("parenthesized_declarator" "attributed_declarator" "function_declarator" "array_declarator" "pointer_declarator" "field_identifier") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("field_declaration_list" (:*unnamed* ("preproc_function_def" "preproc_if" "field_declaration" "preproc_ifdef" "preproc_def" "preproc_call")))
    ("field_designator" (:*unnamed* ("field_identifier")))
    ("field_expression" (:argument ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :field ("field_identifier") :operator nil))
    ("for_statement" (:body ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement") :condition ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :initializer ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "declaration" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :update ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("function_declarator" (:*unnamed* ("attribute_specifier" "gnu_asm_expression") :declarator ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "primitive_type" "field_identifier" "array_declarator") :parameters ("parameter_list")))
    ("function_definition" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier" "declaration" "attribute_declaration" "storage_class_specifier" "type_qualifier" "ms_call_modifier") :body ("compound_statement") :declarator ("parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "array_declarator") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("generic_expression" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "type_descriptor" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("gnu_asm_clobber_list" (:register ("string_literal")))
    ("gnu_asm_expression" (:*unnamed* ("gnu_asm_qualifier") :assembly_code ("string_literal" "concatenated_string") :clobbers ("gnu_asm_clobber_list") :goto_labels ("gnu_asm_goto_list") :input_operands ("gnu_asm_input_operand_list") :output_operands ("gnu_asm_output_operand_list")))
    ("gnu_asm_goto_list" (:label ("identifier")))
    ("gnu_asm_input_operand" (:constraint ("string_literal") :symbol ("identifier") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("gnu_asm_input_operand_list" (:operand ("gnu_asm_input_operand")))
    ("gnu_asm_output_operand" (:constraint ("string_literal") :symbol ("identifier") :value ("identifier")))
    ("gnu_asm_output_operand_list" (:operand ("gnu_asm_output_operand")))
    ("goto_statement" (:label ("statement_identifier")))
    ("if_statement" (:alternative ("else_clause") :condition ("parenthesized_expression") :consequence ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement")))
    ("init_declarator" (:declarator ("parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "array_declarator") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "initializer_list" "field_expression" "unary_expression")))
    ("initializer_list" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "initializer_pair" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "initializer_list" "field_expression" "unary_expression")))
    ("initializer_pair" (:designator ("field_designator" "subscript_designator") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "initializer_list" "field_expression" "unary_expression")))
    ("labeled_statement" (:*unnamed* ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement") :label ("statement_identifier")))
    ("linkage_specification" (:body ("declaration" "function_definition" "declaration_list") :value ("string_literal")))
    ("macro_type_specifier" (:name ("identifier") :type ("type_descriptor")))
    ("ms_based_modifier" (:*unnamed* ("argument_list")))
    ("ms_declspec_modifier" (:*unnamed* ("identifier")))
    ("ms_pointer_modifier" (:*unnamed* ("ms_unaligned_ptr_modifier" "ms_signed_ptr_modifier" "ms_unsigned_ptr_modifier" "ms_restrict_modifier")))
    ("offsetof_expression" (:member ("field_identifier") :type ("type_descriptor")))
    ("parameter_declaration" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier" "storage_class_specifier" "attribute_declaration" "type_qualifier") :declarator ("parenthesized_declarator" "attributed_declarator" "function_declarator" "abstract_pointer_declarator" "abstract_parenthesized_declarator" "identifier" "pointer_declarator" "abstract_array_declarator" "abstract_function_declarator" "array_declarator") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("parameter_list" (:*unnamed* ("variadic_parameter" "identifier" "parameter_declaration")))
    ("parenthesized_declarator" (:*unnamed* ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "primitive_type" "field_identifier" "array_declarator")))
    ("parenthesized_expression" (:*unnamed* ("offsetof_expression" "identifier" "preproc_defined" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("pointer_declarator" (:*unnamed* ("ms_pointer_modifier" "type_qualifier" "ms_based_modifier") :declarator ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "identifier" "pointer_declarator" "primitive_type" "field_identifier" "array_declarator")))
    ("pointer_expression" (:argument ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :operator nil))
    ("preproc_call" (:argument ("preproc_arg") :directive ("preproc_directive")))
    ("preproc_def" (:name ("identifier") :value ("preproc_arg")))
    ("preproc_defined" (:*unnamed* ("identifier")))
    ("preproc_elif" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "field_declaration" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier") :alternative ("preproc_else" "preproc_elif") :condition ("identifier" "preproc_defined" "number_literal" "char_literal" "parenthesized_expression" "binary_expression" "call_expression" "unary_expression")))
    ("preproc_elifdef" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier") :alternative ("preproc_else" "preproc_elif") :name ("identifier")))
    ("preproc_else" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "field_declaration" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier")))
    ("preproc_function_def" (:name ("identifier") :parameters ("preproc_params") :value ("preproc_arg")))
    ("preproc_if" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "field_declaration" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier") :alternative ("preproc_else" "preproc_elif") :condition ("identifier" "preproc_defined" "number_literal" "char_literal" "parenthesized_expression" "binary_expression" "call_expression" "unary_expression")))
    ("preproc_ifdef" (:*unnamed* ("continue_statement" "preproc_if" "seh_leave_statement" "if_statement" "do_statement" "union_specifier" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "attributed_statement" "field_declaration" "switch_statement" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "labeled_statement" "linkage_specification" "preproc_def" "preproc_function_def" "function_definition" "enum_specifier" "for_statement" "seh_try_statement" "declaration" "type_definition" "while_statement" "primitive_type" "expression_statement" "preproc_include" "goto_statement" "sized_type_specifier") :alternative ("preproc_else" "preproc_elif" "preproc_elifdef") :name ("identifier")))
    ("preproc_include" (:path ("string_literal" "identifier" "call_expression" "system_lib_string")))
    ("preproc_params" (:*unnamed* ("identifier")))
    ("return_statement" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "comma_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("seh_except_clause" (:body ("compound_statement") :filter ("parenthesized_expression")))
    ("seh_finally_clause" (:body ("compound_statement")))
    ("seh_try_statement" (:*unnamed* ("seh_finally_clause" "seh_except_clause") :body ("compound_statement")))
    ("sized_type_specifier" (:type ("primitive_type" "type_identifier")))
    ("sizeof_expression" (:type ("type_descriptor") :value ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("string_literal" (:*unnamed* ("string_content" "escape_sequence")))
    ("struct_specifier" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier")))
    ("subscript_designator" (:*unnamed* ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("subscript_expression" (:argument ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :index ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression")))
    ("switch_statement" (:body ("compound_statement") :condition ("parenthesized_expression")))
    ("translation_unit" (:*unnamed* ("preproc_function_def" "continue_statement" "function_definition" "preproc_if" "enum_specifier" "for_statement" "if_statement" "union_specifier" "do_statement" "declaration" "return_statement" "compound_statement" "preproc_ifdef" "case_statement" "type_identifier" "type_definition" "while_statement" "primitive_type" "attributed_statement" "expression_statement" "preproc_include" "break_statement" "macro_type_specifier" "struct_specifier" "preproc_call" "switch_statement" "goto_statement" "labeled_statement" "linkage_specification" "preproc_def" "sized_type_specifier")))
    ("type_definition" (:*unnamed* ("attribute_specifier" "type_qualifier") :declarator ("type_identifier" "parenthesized_declarator" "attributed_declarator" "function_declarator" "array_declarator" "pointer_declarator" "primitive_type") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("type_descriptor" (:*unnamed* ("type_qualifier") :declarator ("abstract_function_declarator" "abstract_pointer_declarator" "abstract_array_declarator" "abstract_parenthesized_declarator") :type ("type_identifier" "primitive_type" "enum_specifier" "sized_type_specifier" "macro_type_specifier" "struct_specifier" "union_specifier")))
    ("unary_expression" (:argument ("offsetof_expression" "identifier" "preproc_defined" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :operator nil))
    ("union_specifier" (:*unnamed* ("attribute_specifier" "ms_declspec_modifier") :body ("field_declaration_list") :name ("type_identifier")))
    ("update_expression" (:argument ("offsetof_expression" "identifier" "char_literal" "parenthesized_expression" "pointer_expression" "compound_literal_expression" "binary_expression" "alignof_expression" "cast_expression" "call_expression" "generic_expression" "conditional_expression" "subscript_expression" "assignment_expression" "false" "number_literal" "gnu_asm_expression" "update_expression" "true" "sizeof_expression" "concatenated_string" "null" "string_literal" "field_expression" "unary_expression") :operator nil))
    ("while_statement" (:body ("continue_statement" "for_statement" "seh_leave_statement" "if_statement" "do_statement" "seh_try_statement" "return_statement" "compound_statement" "case_statement" "while_statement" "attributed_statement" "expression_statement" "switch_statement" "break_statement" "goto_statement" "labeled_statement") :condition ("parenthesized_expression")))
    ("character" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("field_identifier" (:*unnamed* nil))
    ("identifier" (:*unnamed* nil))
    ("ms_restrict_modifier" (:*unnamed* nil))
    ("ms_signed_ptr_modifier" (:*unnamed* nil))
    ("ms_unsigned_ptr_modifier" (:*unnamed* nil))
    ("number_literal" (:*unnamed* nil))
    ("preproc_arg" (:*unnamed* nil))
    ("preproc_directive" (:*unnamed* nil))
    ("primitive_type" (:*unnamed* nil))
    ("statement_identifier" (:*unnamed* nil))
    ("string_content" (:*unnamed* nil))
    ("system_lib_string" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ("type_identifier" (:*unnamed* nil))
    ))
;; END Production rules for c
;; START Inverse production rules for c
(defconst combobulate-rules-c-inverse
  '(("abstract_array_declarator" ("abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "_abstract_declarator" "type_descriptor" "parameter_declaration"))
    ("abstract_function_declarator" ("abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "_abstract_declarator" "type_descriptor" "parameter_declaration"))
    ("abstract_parenthesized_declarator" ("abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "_abstract_declarator" "type_descriptor" "parameter_declaration"))
    ("abstract_pointer_declarator" ("abstract_pointer_declarator" "abstract_parenthesized_declarator" "abstract_array_declarator" "abstract_function_declarator" "_abstract_declarator" "type_descriptor" "parameter_declaration"))
    ("alignof_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("argument_list" ("attribute_specifier" "attribute" "call_expression" "ms_based_modifier"))
    ("array_declarator" ("type_definition" "attributed_declarator" "function_definition" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_type_declarator" "_field_declarator" "_declarator" "array_declarator" "declaration" "init_declarator" "parameter_declaration"))
    ("assignment_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("attribute" ("attribute_declaration"))
    ("attribute_declaration" ("attributed_declarator" "function_definition" "attributed_statement" "field_declaration" "declaration" "parameter_declaration"))
    ("attribute_specifier" ("type_definition" "function_definition" "function_declarator" "enum_specifier" "field_declaration" "struct_specifier" "union_specifier" "declaration" "parameter_declaration"))
    ("attributed_declarator" ("type_definition" "attributed_declarator" "function_definition" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_type_declarator" "_field_declarator" "_declarator" "array_declarator" "declaration" "init_declarator" "parameter_declaration"))
    ("attributed_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("binary_expression" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("bitfield_clause" ("field_declaration"))
    ("break_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("call_expression" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "preproc_include" "update_expression" "initializer_list" "unary_expression"))
    ("case_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef"))
    ("cast_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("char_literal" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("character" ("char_literal"))
    ("comma_expression" ("parenthesized_expression" "for_statement" "expression_statement" "comma_expression" "return_statement"))
    ("compound_literal_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("compound_statement" ("preproc_if" "if_statement" "do_statement" "compound_statement" "preproc_ifdef" "case_statement" "preproc_else" "preproc_elifdef" "attributed_statement" "switch_statement" "seh_except_clause" "else_clause" "labeled_statement" "seh_finally_clause" "function_definition" "declaration_list" "for_statement" "seh_try_statement" "_statement" "argument_list" "translation_unit" "preproc_elif" "while_statement"))
    ("concatenated_string" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "gnu_asm_expression" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("conditional_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("continue_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("declaration" ("translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "for_statement" "compound_statement" "linkage_specification" "preproc_ifdef" "case_statement"))
    ("declaration_list" ("linkage_specification"))
    ("do_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("else_clause" ("if_statement"))
    ("enum_specifier" ("type_definition" "translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "_type_specifier" "field_declaration" "preproc_ifdef" "declaration" "compound_statement" "type_descriptor" "parameter_declaration"))
    ("enumerator" ("enumerator_list"))
    ("enumerator_list" ("enum_specifier"))
    ("escape_sequence" ("string_literal" "char_literal"))
    ("expression_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("false" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("field_declaration" ("preproc_else" "preproc_elif" "preproc_if" "field_declaration_list" "preproc_ifdef"))
    ("field_declaration_list" ("struct_specifier" "union_specifier"))
    ("field_designator" ("initializer_pair"))
    ("field_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("field_identifier" ("attributed_declarator" "offsetof_expression" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_field_declarator" "array_declarator" "field_designator" "field_expression"))
    ("for_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("function_declarator" ("type_definition" "attributed_declarator" "function_definition" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_type_declarator" "_field_declarator" "_declarator" "array_declarator" "declaration" "init_declarator" "parameter_declaration"))
    ("function_definition" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "compound_statement" "linkage_specification" "preproc_ifdef"))
    ("generic_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("gnu_asm_clobber_list" ("gnu_asm_expression"))
    ("gnu_asm_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "function_declarator" "pointer_expression" "for_statement" "declaration" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("gnu_asm_goto_list" ("gnu_asm_expression"))
    ("gnu_asm_input_operand" ("gnu_asm_input_operand_list"))
    ("gnu_asm_input_operand_list" ("gnu_asm_expression"))
    ("gnu_asm_output_operand" ("gnu_asm_output_operand_list"))
    ("gnu_asm_output_operand_list" ("gnu_asm_expression"))
    ("gnu_asm_qualifier" ("gnu_asm_expression"))
    ("goto_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("identifier" ("gnu_asm_input_operand" "preproc_defined" "gnu_asm_output_operand" "preproc_if" "parenthesized_expression" "attribute" "_declarator" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "preproc_params" "return_statement" "preproc_ifdef" "case_statement" "ms_declspec_modifier" "preproc_elifdef" "abstract_array_declarator" "macro_type_specifier" "sizeof_expression" "concatenated_string" "parameter_list" "field_expression" "_expression" "preproc_def" "subscript_designator" "preproc_function_def" "attributed_declarator" "function_definition" "function_declarator" "pointer_expression" "for_statement" "declaration" "call_expression" "init_declarator" "parameter_declaration" "argument_list" "assignment_expression" "subscript_expression" "gnu_asm_goto_list" "preproc_elif" "parenthesized_declarator" "bitfield_clause" "enumerator" "pointer_declarator" "expression_statement" "comma_expression" "preproc_include" "update_expression" "initializer_list" "unary_expression"))
    ("if_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("init_declarator" ("declaration"))
    ("initializer_list" ("init_declarator" "compound_literal_expression" "initializer_pair" "initializer_list"))
    ("initializer_pair" ("initializer_list"))
    ("labeled_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("linkage_specification" ("translation_unit" "preproc_else" "preproc_elif" "preproc_elifdef" "preproc_if" "declaration_list" "compound_statement" "preproc_ifdef"))
    ("macro_type_specifier" ("type_definition" "translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "_type_specifier" "field_declaration" "preproc_ifdef" "declaration" "compound_statement" "type_descriptor" "parameter_declaration"))
    ("ms_based_modifier" ("pointer_declarator"))
    ("ms_call_modifier" ("function_definition"))
    ("ms_declspec_modifier" ("function_definition" "field_declaration" "struct_specifier" "union_specifier" "declaration" "parameter_declaration"))
    ("ms_pointer_modifier" ("pointer_declarator"))
    ("ms_restrict_modifier" ("ms_pointer_modifier"))
    ("ms_signed_ptr_modifier" ("ms_pointer_modifier"))
    ("ms_unaligned_ptr_modifier" ("ms_pointer_modifier"))
    ("ms_unsigned_ptr_modifier" ("ms_pointer_modifier"))
    ("null" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("number_literal" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("offsetof_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("parameter_declaration" ("parameter_list"))
    ("parameter_list" ("abstract_function_declarator" "function_declarator"))
    ("parenthesized_declarator" ("type_definition" "attributed_declarator" "function_definition" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_type_declarator" "_field_declarator" "_declarator" "array_declarator" "declaration" "init_declarator" "parameter_declaration"))
    ("parenthesized_expression" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "if_statement" "do_statement" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "switch_statement" "abstract_array_declarator" "seh_except_clause" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "while_statement" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("pointer_declarator" ("type_definition" "attributed_declarator" "function_definition" "function_declarator" "parenthesized_declarator" "pointer_declarator" "field_declaration" "_type_declarator" "_field_declarator" "_declarator" "array_declarator" "declaration" "init_declarator" "parameter_declaration"))
    ("pointer_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("preproc_arg" ("preproc_function_def" "preproc_def" "preproc_call"))
    ("preproc_call" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "field_declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_def" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "field_declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_defined" ("preproc_elif" "preproc_if" "parenthesized_expression" "binary_expression" "argument_list" "unary_expression"))
    ("preproc_directive" ("preproc_call"))
    ("preproc_elif" ("preproc_ifdef" "preproc_elif" "preproc_elifdef" "preproc_if"))
    ("preproc_elifdef" ("preproc_ifdef"))
    ("preproc_else" ("preproc_ifdef" "preproc_elif" "preproc_elifdef" "preproc_if"))
    ("preproc_function_def" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "field_declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_if" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "field_declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_ifdef" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "field_declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_include" ("translation_unit" "preproc_else" "preproc_elif" "preproc_elifdef" "preproc_if" "declaration_list" "compound_statement" "preproc_ifdef"))
    ("preproc_params" ("preproc_function_def"))
    ("primitive_type" ("preproc_if" "_type_specifier" "_type_declarator" "array_declarator" "compound_statement" "type_descriptor" "preproc_ifdef" "preproc_else" "preproc_elifdef" "field_declaration" "attributed_declarator" "function_definition" "function_declarator" "declaration_list" "enum_specifier" "declaration" "parameter_declaration" "type_definition" "translation_unit" "preproc_elif" "parenthesized_declarator" "pointer_declarator" "sized_type_specifier"))
    ("return_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("seh_except_clause" ("seh_try_statement"))
    ("seh_finally_clause" ("seh_try_statement"))
    ("seh_leave_statement" ("preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("seh_try_statement" ("preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("sized_type_specifier" ("type_definition" "translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "_type_specifier" "field_declaration" "preproc_ifdef" "declaration" "compound_statement" "type_descriptor" "parameter_declaration"))
    ("sizeof_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("statement_identifier" ("labeled_statement" "goto_statement"))
    ("storage_class_specifier" ("field_declaration" "declaration" "function_definition" "parameter_declaration"))
    ("string_content" ("string_literal"))
    ("string_literal" ("gnu_asm_input_operand" "gnu_asm_output_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "concatenated_string" "linkage_specification" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "gnu_asm_clobber_list" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "gnu_asm_expression" "expression_statement" "comma_expression" "preproc_include" "update_expression" "initializer_list" "unary_expression"))
    ("struct_specifier" ("type_definition" "translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "_type_specifier" "field_declaration" "preproc_ifdef" "declaration" "compound_statement" "type_descriptor" "parameter_declaration"))
    ("subscript_designator" ("initializer_pair"))
    ("subscript_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("switch_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    ("system_lib_string" ("preproc_include"))
    ("true" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("type_definition" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "compound_statement" "preproc_ifdef" "case_statement"))
    ("type_descriptor" ("offsetof_expression" "compound_literal_expression" "macro_type_specifier" "sizeof_expression" "alignof_expression" "cast_expression" "generic_expression"))
    ("type_identifier" ("preproc_if" "_type_specifier" "_type_declarator" "union_specifier" "array_declarator" "compound_statement" "type_descriptor" "preproc_ifdef" "preproc_else" "preproc_elifdef" "field_declaration" "struct_specifier" "attributed_declarator" "function_definition" "function_declarator" "declaration_list" "enum_specifier" "declaration" "parameter_declaration" "type_definition" "translation_unit" "preproc_elif" "parenthesized_declarator" "pointer_declarator" "sized_type_specifier"))
    ("type_qualifier" ("type_definition" "function_definition" "abstract_pointer_declarator" "pointer_declarator" "field_declaration" "abstract_array_declarator" "declaration" "array_declarator" "type_descriptor" "parameter_declaration"))
    ("unary_expression" ("gnu_asm_input_operand" "preproc_if" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "preproc_elif" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("union_specifier" ("type_definition" "translation_unit" "preproc_elif" "function_definition" "preproc_elifdef" "preproc_else" "declaration_list" "preproc_if" "_type_specifier" "field_declaration" "preproc_ifdef" "declaration" "compound_statement" "type_descriptor" "parameter_declaration"))
    ("update_expression" ("gnu_asm_input_operand" "parenthesized_expression" "array_declarator" "binary_expression" "cast_expression" "initializer_pair" "generic_expression" "conditional_expression" "return_statement" "case_statement" "abstract_array_declarator" "sizeof_expression" "field_expression" "_expression" "subscript_designator" "pointer_expression" "for_statement" "call_expression" "init_declarator" "argument_list" "assignment_expression" "subscript_expression" "bitfield_clause" "enumerator" "expression_statement" "comma_expression" "update_expression" "initializer_list" "unary_expression"))
    ("variadic_parameter" ("parameter_list"))
    ("while_statement" ("translation_unit" "preproc_elif" "preproc_else" "preproc_elifdef" "preproc_if" "declaration_list" "while_statement" "attributed_statement" "for_statement" "if_statement" "do_statement" "else_clause" "_statement" "compound_statement" "labeled_statement" "preproc_ifdef" "case_statement"))
    )
  )
;; END Inverse production rules for c
;; START All node types in c
(defconst combobulate-rules-c-types
  '("_abstract_declarator" "_declarator" "_expression" "_field_declarator" "_statement" "_type_declarator" "_type_specifier" "abstract_array_declarator" "abstract_function_declarator" "abstract_parenthesized_declarator" "abstract_pointer_declarator" "alignof_expression" "argument_list" "array_declarator" "assignment_expression" "attribute" "attribute_declaration" "attribute_specifier" "attributed_declarator" "attributed_statement" "binary_expression" "bitfield_clause" "break_statement" "call_expression" "case_statement" "cast_expression" "char_literal" "character" "comma_expression" "comment" "compound_literal_expression" "compound_statement" "concatenated_string" "conditional_expression" "continue_statement" "declaration" "declaration_list" "do_statement" "else_clause" "enum_specifier" "enumerator" "enumerator_list" "escape_sequence" "expression_statement" "false" "field_declaration" "field_declaration_list" "field_designator" "field_expression" "field_identifier" "for_statement" "function_declarator" "function_definition" "generic_expression" "gnu_asm_clobber_list" "gnu_asm_expression" "gnu_asm_goto_list" "gnu_asm_input_operand" "gnu_asm_input_operand_list" "gnu_asm_output_operand" "gnu_asm_output_operand_list" "gnu_asm_qualifier" "goto_statement" "identifier" "if_statement" "init_declarator" "initializer_list" "initializer_pair" "labeled_statement" "linkage_specification" "macro_type_specifier" "ms_based_modifier" "ms_call_modifier" "ms_declspec_modifier" "ms_pointer_modifier" "ms_restrict_modifier" "ms_signed_ptr_modifier" "ms_unaligned_ptr_modifier" "ms_unsigned_ptr_modifier" "null" "number_literal" "offsetof_expression" "parameter_declaration" "parameter_list" "parenthesized_declarator" "parenthesized_expression" "pointer_declarator" "pointer_expression" "preproc_arg" "preproc_call" "preproc_def" "preproc_defined" "preproc_directive" "preproc_elif" "preproc_elifdef" "preproc_else" "preproc_function_def" "preproc_if" "preproc_ifdef" "preproc_include" "preproc_params" "primitive_type" "return_statement" "seh_except_clause" "seh_finally_clause" "seh_leave_statement" "seh_try_statement" "sized_type_specifier" "sizeof_expression" "statement_identifier" "storage_class_specifier" "string_content" "string_literal" "struct_specifier" "subscript_designator" "subscript_expression" "switch_statement" "system_lib_string" "translation_unit" "true" "type_definition" "type_descriptor" "type_identifier" "type_qualifier" "unary_expression" "union_specifier" "update_expression" "variadic_parameter" "while_statement")
  )
;; END All node types in c

;; START Production rules for html
(defconst combobulate-rules-html
  '(("attribute" (:*unnamed* ("attribute_name" "quoted_attribute_value" "attribute_value")))
    ("element" (:*unnamed* ("element" "doctype" "style_element" "self_closing_tag" "end_tag" "script_element" "entity" "erroneous_end_tag" "text" "start_tag")))
    ("end_tag" (:*unnamed* ("tag_name")))
    ("erroneous_end_tag" (:*unnamed* ("erroneous_end_tag_name")))
    ("fragment" (:*unnamed* ("element" "doctype" "style_element" "entity" "erroneous_end_tag" "text" "script_element")))
    ("quoted_attribute_value" (:*unnamed* ("attribute_value")))
    ("script_element" (:*unnamed* ("raw_text" "start_tag" "end_tag")))
    ("self_closing_tag" (:*unnamed* ("attribute" "tag_name")))
    ("start_tag" (:*unnamed* ("attribute" "tag_name")))
    ("style_element" (:*unnamed* ("raw_text" "start_tag" "end_tag")))
    ("attribute_name" (:*unnamed* nil))
    ("attribute_value" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("entity" (:*unnamed* nil))
    ("erroneous_end_tag_name" (:*unnamed* nil))
    ("raw_text" (:*unnamed* nil))
    ("tag_name" (:*unnamed* nil))
    ("text" (:*unnamed* nil))
    ))
;; END Production rules for html
;; START Inverse production rules for html
(defconst combobulate-rules-html-inverse
  '(("attribute" ("self_closing_tag" "start_tag"))
    ("attribute_name" ("attribute"))
    ("attribute_value" ("attribute" "quoted_attribute_value"))
    ("doctype" ("fragment" "element"))
    ("element" ("fragment" "element"))
    ("end_tag" ("element" "style_element" "script_element"))
    ("entity" ("fragment" "element"))
    ("erroneous_end_tag" ("fragment" "element"))
    ("erroneous_end_tag_name" ("erroneous_end_tag"))
    ("quoted_attribute_value" ("attribute"))
    ("raw_text" ("style_element" "script_element"))
    ("script_element" ("fragment" "element"))
    ("self_closing_tag" ("element"))
    ("start_tag" ("element" "style_element" "script_element"))
    ("style_element" ("fragment" "element"))
    ("tag_name" ("self_closing_tag" "start_tag" "end_tag"))
    ("text" ("fragment" "element"))
    )
  )
;; END Inverse production rules for html
;; START All node types in html
(defconst combobulate-rules-html-types
  '("attribute" "attribute_name" "attribute_value" "comment" "doctype" "element" "end_tag" "entity" "erroneous_end_tag" "erroneous_end_tag_name" "fragment" "quoted_attribute_value" "raw_text" "script_element" "self_closing_tag" "start_tag" "style_element" "tag_name" "text")
  )
;; END All node types in html

;; START Production rules for toml
(defconst combobulate-rules-toml
  '(("array" (:*unnamed* ("array" "string" "boolean" "local_date" "float" "local_time" "offset_date_time" "integer" "inline_table" "local_date_time")))
    ("document" (:*unnamed* ("table_array_element" "pair" "table")))
    ("dotted_key" (:*unnamed* ("bare_key" "quoted_key" "dotted_key")))
    ("inline_table" (:*unnamed* ("pair")))
    ("pair" (:*unnamed* ("array" "string" "boolean" "local_date" "float" "quoted_key" "local_time" "dotted_key" "offset_date_time" "integer" "bare_key" "inline_table" "local_date_time")))
    ("quoted_key" (:*unnamed* ("escape_sequence")))
    ("string" (:*unnamed* ("escape_sequence")))
    ("table" (:*unnamed* ("bare_key" "pair" "dotted_key" "quoted_key")))
    ("table_array_element" (:*unnamed* ("bare_key" "pair" "dotted_key" "quoted_key")))
    ("bare_key" (:*unnamed* nil))
    ("boolean" (:*unnamed* nil))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("local_date" (:*unnamed* nil))
    ("local_date_time" (:*unnamed* nil))
    ("local_time" (:*unnamed* nil))
    ("offset_date_time" (:*unnamed* nil))
    ))
;; END Production rules for toml
;; START Inverse production rules for toml
(defconst combobulate-rules-toml-inverse
  '(("array" ("array" "pair"))
    ("bare_key" ("table_array_element" "pair" "table" "dotted_key"))
    ("boolean" ("array" "pair"))
    ("dotted_key" ("table_array_element" "pair" "table" "dotted_key"))
    ("escape_sequence" ("quoted_key" "string"))
    ("float" ("array" "pair"))
    ("inline_table" ("array" "pair"))
    ("integer" ("array" "pair"))
    ("local_date" ("array" "pair"))
    ("local_date_time" ("array" "pair"))
    ("local_time" ("array" "pair"))
    ("offset_date_time" ("array" "pair"))
    ("pair" ("inline_table" "document" "table" "table_array_element"))
    ("quoted_key" ("table_array_element" "pair" "table" "dotted_key"))
    ("string" ("array" "pair"))
    ("table" ("document"))
    ("table_array_element" ("document"))
    )
  )
;; END Inverse production rules for toml
;; START All node types in toml
(defconst combobulate-rules-toml-types
  '("array" "bare_key" "boolean" "comment" "document" "dotted_key" "escape_sequence" "float" "inline_table" "integer" "local_date" "local_date_time" "local_time" "offset_date_time" "pair" "quoted_key" "string" "table" "table_array_element")
  )
;; END All node types in toml

;; START Production rules for json
(defconst combobulate-rules-json
  '(("_value" (:*unnamed* ("array" "false" "string" "null" "number" "true" "object")))
    ("array" (:*unnamed* ("array" "false" "string" "null" "number" "true" "object")))
    ("document" (:*unnamed* ("array" "false" "string" "null" "number" "true" "object")))
    ("object" (:*unnamed* ("pair")))
    ("pair" (:key ("number" "string") :value ("array" "false" "string" "null" "number" "true" "object")))
    ("string" (:*unnamed* ("string_content")))
    ("string_content" (:*unnamed* ("escape_sequence")))
    ("comment" (:*unnamed* nil))
    ("escape_sequence" (:*unnamed* nil))
    ("false" (:*unnamed* nil))
    ("null" (:*unnamed* nil))
    ("number" (:*unnamed* nil))
    ("true" (:*unnamed* nil))
    ))
;; END Production rules for json
;; START Inverse production rules for json
(defconst combobulate-rules-json-inverse
  '(("array" ("array" "_value" "document" "pair"))
    ("escape_sequence" ("string_content"))
    ("false" ("array" "_value" "document" "pair"))
    ("null" ("array" "_value" "document" "pair"))
    ("number" ("array" "_value" "document" "pair"))
    ("object" ("array" "_value" "document" "pair"))
    ("pair" ("object"))
    ("string" ("array" "_value" "document" "pair"))
    ("string_content" ("string"))
    ("true" ("array" "_value" "document" "pair"))
    )
  )
;; END Inverse production rules for json
;; START All node types in json
(defconst combobulate-rules-json-types
  '("_value" "array" "comment" "document" "escape_sequence" "false" "null" "number" "object" "pair" "string" "string_content" "true")
  )
;; END All node types in json

;; START Auto-generated list of all languages
(defconst combobulate-rules-languages
  '(c css go html javascript json jsx python toml tsx typescript yaml)
  "A list of all the languages that have production rules.")
;; END Auto-generated list of all languages
;; START Auto-generated alist of all languages and their production rules
(defconst combobulate-rules-alist
  `((c ,combobulate-rules-c)
    (css ,combobulate-rules-css)
    (go ,combobulate-rules-go)
    (html ,combobulate-rules-html)
    (javascript ,combobulate-rules-javascript)
    (json ,combobulate-rules-json)
    (jsx ,combobulate-rules-jsx)
    (python ,combobulate-rules-python)
    (toml ,combobulate-rules-toml)
    (tsx ,combobulate-rules-tsx)
    (typescript ,combobulate-rules-typescript)
    (yaml ,combobulate-rules-yaml)
    ))

(defconst combobulate-rules-inverse-alist
  `((c ,combobulate-rules-c-inverse)
    (css ,combobulate-rules-css-inverse)
    (go ,combobulate-rules-go-inverse)
    (html ,combobulate-rules-html-inverse)
    (javascript ,combobulate-rules-javascript-inverse)
    (json ,combobulate-rules-json-inverse)
    (jsx ,combobulate-rules-jsx-inverse)
    (python ,combobulate-rules-python-inverse)
    (toml ,combobulate-rules-toml-inverse)
    (tsx ,combobulate-rules-tsx-inverse)
    (typescript ,combobulate-rules-typescript-inverse)
    (yaml ,combobulate-rules-yaml-inverse)
    ))

(defconst combobulate-rules-types-alist
  `((c ,combobulate-rules-c-types)
    (css ,combobulate-rules-css-types)
    (go ,combobulate-rules-go-types)
    (html ,combobulate-rules-html-types)
    (javascript ,combobulate-rules-javascript-types)
    (json ,combobulate-rules-json-types)
    (jsx ,combobulate-rules-jsx-types)
    (python ,combobulate-rules-python-types)
    (toml ,combobulate-rules-toml-types)
    (tsx ,combobulate-rules-tsx-types)
    (typescript ,combobulate-rules-typescript-types)
    (yaml ,combobulate-rules-yaml-types)
    ))
;; END Auto-generated alist of all languages and their production rules

(provide 'combobulate-rules)
